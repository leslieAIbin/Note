---
typora-root-url: /images
---



# SpringBoot 源码解读

# 项目环境准备

![](/1.png)

前端传过来的请求，会经过分发器，找到一个合适的控制器，然后会获得一个model，然后赋予给视图层，然后渲染给用户

Spring框架：



![](/2.png)

MyBatis： orm 关系型数据库 

![](/3.png)

idea创建一个ssm项目

![](/4.png)

![](/5.png)

## 直接上手SpringBoot2 + Mybatis





![](/6.png)

### pom.xml

服务器数据库5.x 就用虚拟机那个环境

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.7.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<groupId>com.example</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>sb2</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>1.3.3</version>
		</dependency>

<!--			<dependency>-->
<!--				<groupId>mysql</groupId>-->
<!--				<artifactId>mysql-connector-java</artifactId>-->
<!--				<version>8.0.13</version>-->
<!--			</dependency>-->

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.mybatis.generator</groupId>
				<artifactId>mybatis-generator-maven-plugin</artifactId>
				<version>1.3.5</version>
				<dependencies>
					<dependency>
						<groupId>mysql</groupId>
						<artifactId>mysql-connector-java</artifactId>
						<version>5.1.8</version>
					</dependency>
				</dependencies>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>

```

一定要注意各种版本号

### generatorConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE generatorConfiguration        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"><generatorConfiguration>    <context id="testTables" targetRuntime="MyBatis3">        <commentGenerator>            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->            <property name="suppressAllComments" value="true"/>        </commentGenerator>        <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->        <jdbcConnection driverClass="com.mysql.jdbc.Driver"                        connectionURL="jdbc:mysql://192.168.56.101:3306/test" userId="root"                        password="123456">        </jdbcConnection>        <!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和            NUMERIC 类型解析为java.math.BigDecimal -->        <javaTypeResolver>            <property name="forceBigDecimals" value="false"/>        </javaTypeResolver>        <!-- targetProject:生成PO类的位置 -->        <javaModelGenerator targetPackage="com.example.sb2.bean"                            targetProject="src/main/java">            <!-- enableSubPackages:是否让schema作为包的后缀 -->            <property name="enableSubPackages" value="false"/>            <!-- 从数据库返回的值被清理前后的空格 -->            <property name="trimStrings" value="true"/>        </javaModelGenerator>        <!-- targetProject:mapper映射文件生成的位置 -->        <sqlMapGenerator targetPackage="mapper"                         targetProject="src/main/resources">            <!-- enableSubPackages:是否让schema作为包的后缀 -->            <property name="enableSubPackages" value="false"/>        </sqlMapGenerator>        <!-- targetPackage：mapper接口生成的位置 -->        <javaClientGenerator type="XMLMAPPER"                             targetPackage="com.example.sb2.mapper"                             targetProject="src/main/java">            <!-- enableSubPackages:是否让schema作为包的后缀 -->            <property name="enableSubPackages" value="false"/>        </javaClientGenerator>        <!-- 指定数据库表 -->        <table schema="" tableName="demo"></table>    </context></generatorConfiguration>
```

### 属性配置

```
server.port=8080spring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://192.168.56.101:3306/test?useUnicode=true&characterEncoding=utf8&serverTimezone=GMTspring.datasource.driver-class-name=com.mysql.jdbc.Drivermybatis.mapper-locations=classpath:mapper/*.xmlmybatis.type-aliases-package=com.example.sb2.beanmybatis.configuration.map-underscore-to-camel-case=true
```

重写demo 实体类的 toString方法

### service

```java
package com.example.sb2.service;import com.example.sb2.bean.Demo;import com.example.sb2.mapper.DemoMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.util.Optional;@Componentpublic class DemoService {    @Autowired    private DemoMapper demoMapper;    public Demo getDemoById(Long id) {        return Optional.ofNullable(demoMapper.selectByPrimaryKey(id)).orElse(null);    }}
```

### 控制器

```java
package com.example.sb2.controller;import com.example.sb2.bean.Demo;import com.example.sb2.service.DemoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.Optional;@Controller@RequestMapping("/demo")public class DemoController {    @Autowired    private DemoService demoService;    @RequestMapping("/hello/{id}")    @ResponseBody    public String hello(@PathVariable(value = "id") Long id) {        return Optional.ofNullable(demoService.getDemoById(id)).map(Demo::toString).orElse("empty String");    }}
```

### sb2搭建流程

![](/7.png)

**总结：**

耗时短

配置文件简洁

不关注版本管理

易上手

# 启动流程的介绍

https://www.cnblogs.com/theRhyme/p/11057233.html



SpringBoot2 的启动流程

一行来完成启动

```java
@SpringBootApplication@MapperScan("com.example.sb2.mapper")
public class Sb2Application {   
    public static void main(String[] args) {      
        SpringApplication.run(Sb2Application.class, args);   
    }}
```

run方法点进去  SpringApplication + run

SpringApplication 是进行一些赋值

```java
	public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
		this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, "PrimarySources must not be null");
		this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
		this.webApplicationType = WebApplicationType.deduceFromClasspath();
		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
		this.mainApplicationClass = deduceMainApplicationClass();
	}	public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
		return new SpringApplication(primarySources).run(args);
	}
```

run 方法

```
public ConfigurableApplicationContext run(String... args) {
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		ConfigurableApplicationContext context = null;
		Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
		configureHeadlessProperty();
		SpringApplicationRunListeners listeners = getRunListeners(args);
		listeners.starting();
		try {
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
			configureIgnoreBeanInfo(environment);
			Banner printedBanner = printBanner(environment);
			context = createApplicationContext();
			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
					new Class[] { ConfigurableApplicationContext.class }, context);
			prepareContext(context, environment, listeners, applicationArguments, printedBanner);
			refreshContext(context);
			afterRefresh(context, applicationArguments);
			stopWatch.stop();
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
			}
			listeners.started(context);
			callRunners(context, applicationArguments);
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, listeners);
			throw new IllegalStateException(ex);
		}

		try {
			listeners.running(context);
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, null);
			throw new IllegalStateException(ex);
		}
		return context;
	}
```



## 启动流程

* 框架初始化

* 框架启动

* 自动化装配

  

## 框架初始化步骤

* 加载资源 resource 读取

* 传过来的主类，一般是主类

* 1.x 环境只有两个（标准+web） 2.x多了一个reactive 环境

* 监听器用来监听关键事件

* 配置main方法所在类，一般和primarySources是一样

  

![](/8.png)

有一个计时器，项目启动之后，会在控制台上打印配置的时间

headless 实际上是就是设置系统属性java.awt.headless，在我们的例子中该属性会被设置为true，因为我们开发的是服务器程序，一般运行在没有显示器和键盘的环境。关于java中的headless模式，更多信息可以参考[这里](http://www.oracle.com/technetwork/articles/javase/headless-136834.html)。

配置上下文环境

刷新上下文：调用的是spring里的方法，加载bean

![](/9.png)

## 框架自动化装配的步骤

![](/10.png)

  ### 整体流程概览

用mindmaster来画图

这个部分图片太大了，直接用mindmaster来看

![](/11.png)

# 系统初始化器概览

https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html#testing

* 类名：ApplicationContextInitializer

* 介绍：Spring容器刷新之前执行的一个回调函数

* 作用：向SpringBoot容器中注册属性

* 使用：继承接口自定义实现

  

# 自己动手写一个系统初始化器

idea 快速实例化的 先写上 new  对象名 ，然后 ctrl+alt+v

第一个 系统 初始化器

```java
package com.example.sb2.initializer;

import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;

import java.util.*;


// 定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序
@Order(1)
public class FirstInitializer implements
        ApplicationContextInitializer<ConfigurableApplicationContext> {

    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        // 获得环境
        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        Map<String,Object> map = new HashMap<>();
        map.put("key1", "value1");
        // map打包成一个属性
        MapPropertySource mapPropertySource = new MapPropertySource("firstInitializer", map);
        environment.getPropertySources().addLast(mapPropertySource);
        System.out.println("******** Run FirstInitializer ******** ");
    }
}

```

## meta-inf

   **为了提供存档的便签信息**，出现了Manifest.mf文件，jar文件中有一个特定的目录来存放标签信息：META-INF目录，主要应关注其中

一个名叫**manifest.mf的文件，它包含了jar文件的内容描述，在应用程序运行时向JVM提供应用程序的信息**。

关于MEATA-INF目录的作用，百度上的解释是这样的（正规的解释）：

​        **META-INF相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务manifest.mf文件，在用jar打包时自动生成。**

 

​        **jar文件都有一个默认产生的META-INF目录和其中的manifest.mf文件  使用jar命令可以直接产生META-INF目录和manifest.mf文件，**例如：



在resource文件目录下面创建 META-INF文件夹

里面创建文件夹spring.factories

该文件里写入org.springframework.context.ApplicationContextInitializer=com.example.sb2.initializer.FirstInitializer



## 创建测试服务类

```java
package com.example.sb2.service;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationContextInitializer;
import org.springframework.stereotype.Component;

@Component
public class TestService implements
        ApplicationContextAware {
    private ApplicationContext applicationContext;


    @Override
    public void setApplicationContext(ApplicationContext applicationContext)
            throws BeansException {
        this.applicationContext = applicationContext;
    }


    public String test() {
        return applicationContext.getEnvironment().getProperty("key1");
    }
}

```





## 补充知识：ApplicationContextAware

https://www.imooc.com/article/257762

http://www.pinhuba.com/spring/101049.htm

当一个类可以实现了这个接口，这个类就可以方便获得ApplicationContext中的所有bean，换句话说，就是这个类可以直接获取spring配置文件中，所有有引用到的bean对象



某个地方需要使用到ApplicationContext中的某个bean（companyService）

## 控制器





```java
package com.example.sb2.controller;

import com.example.sb2.bean.Demo;
import com.example.sb2.service.DemoService;
import com.example.sb2.service.TestService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.Optional;

@Controller
@RequestMapping("/demo")
public class DemoController {
    @Autowired
    private DemoService demoService;
    @Autowired
    private TestService testService;

    @RequestMapping("/hello/{id}")
    @ResponseBody
    public String hello(@PathVariable(value = "id") Long id) {
        return Optional.ofNullable(demoService.getDemoById(id)).map(Demo::toString).orElse("empty String");
    }


    @RequestMapping("test")
    @ResponseBody
    public String test(){
        return testService.test();
    }

}

```

运行项目  可以看到控制台里已经有打印的信息了

然后访问

http://localhost:8080/demo/test

可以返回value1



## 新建第二个初始化器

```java
package com.example.sb2.initializer;

import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;

import java.util.HashMap;
import java.util.Map;


// 定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序
@Order(2)
public class SecondInitializer implements
        ApplicationContextInitializer<ConfigurableApplicationContext> {

    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        // 获得环境
        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        Map<String,Object> map = new HashMap<>();
        map.put("key2", "value2");
        // map打包成一个属性
        MapPropertySource mapPropertySource = new MapPropertySource("secondInitializer", map);
        environment.getPropertySources().addLast(mapPropertySource);
        System.out.println("******** Run SecondInitializer ******** ");
    }
}

```

## 修改启动类

```java
package com.example.sb2.initializer;

import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;

import java.util.HashMap;
import java.util.Map;


// 定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序
@Order(2)
public class SecondInitializer implements
        ApplicationContextInitializer<ConfigurableApplicationContext> {

    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        // 获得环境
        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        Map<String,Object> map = new HashMap<>();
        map.put("key2", "value2");
        // map打包成一个属性
        MapPropertySource mapPropertySource = new MapPropertySource("secondInitializer", map);
        environment.getPropertySources().addLast(mapPropertySource);
        System.out.println("******** Run SecondInitializer ******** ");
    }
}

```

启动项目可以看到项目启动之后，控制台里成功打印信息

**@Order(xxx)** 就是bean执行的顺序  和控制台里的输出信息一致

## 第三个初始化器

```java
package com.example.sb2.initializer;

import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;

import java.util.HashMap;
import java.util.Map;


// 定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序
@Order(3)
public class ThirdInitializer implements
        ApplicationContextInitializer<ConfigurableApplicationContext> {

    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        // 获得环境
        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        Map<String,Object> map = new HashMap<>();
        map.put("key3", "value3");
        // map打包成一个属性
        MapPropertySource mapPropertySource = new MapPropertySource("thirdInitializer", map);
        environment.getPropertySources().addLast(mapPropertySource);
        System.out.println("******** Run ThirdInitializer ******** ");
    }
}

```

修改属性文件

```
server.port=8080
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.url=jdbc:mysql://192.168.56.101:3306/test?useUnicode=true&characterEncoding=utf8&serverTimezone=GMT
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
mybatis.mapper-locations=classpath:mapper/*.xml
mybatis.type-aliases-package=com.example.sb2.bean
mybatis.configuration.map-underscore-to-camel-case=true


context.initializer.classes=com.example.sb2.initializer.ThirdInitializer
```

启动项目 成功初始化

但是顺序好像和Order定义的不一致，后面分析原因

******** Run ThirdInitializer ******** 
******** Run FirstInitializer ******** 
******** Run SecondInitializer ******** 

## 总结

**实现方式一：**

实现ApplicationContextInitiallizer接口

spring.factories内填写接口实现

key值为org.springframework.context.ApplicationContextInitializer

**实现方式二：**

实现ApplicationContextInitiallizer接口

SpringApplication 类初始后设置进去

**实现方式三：**

实现ApplicationContextInitiallizer接口

application.propreties内填写接口实现

key值就是context.initializer.classes

<b>注意事项</b>

都要实现ApplicationContextInitializer接口

Order值越小 越先执行

application.properties中定义的优先于其他方式

# 工厂加载机制解析（SpringFactoriesLoader）

上一节自定义初始化器是如何被spring识别并加载的呢？

idea 查找类： ctrl+n

## 介绍

可以读取源码上面的英文介绍

* 框架内部使用的通用工厂加载机制

* 从classpath下多个jar包特定的位置读取文件并初始化类

* 文件内容必须是kv形式，即properties类型

* key是全限定名（抽象类|接口），value是实现，多个实现用，分割

  

![](/8.png)

在配置系统初始化器的时候就已经调用SpringFatoriesLoader加载了bean

先把启动类里面 新加的自定义初始化器的代码全注释了，恢复到原来的样子

![](/12.png)

```
	setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
```

```java
	private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {
		ClassLoader classLoader = getClassLoader();
		// Use names and ensure unique to protect against duplicates
        /// 调用SpringFactoriesLoader类加载spring.factories文件
		Set<String> names = new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
        //  
        // 实例化获取到的类实例
		List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
        // 对结果进行排序
		AnnotationAwareOrderComparator.sort(instances);
		return instances;
	}
```

```
public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
```

![](/15.png)

不断打断点，然后点击蓝色框中的运行箭头

ctrl+n 搜索spring.factories  勾选上include non-project files

有很多的spring.factories 

## SpringFactoriesLoader作用：

springboot框架从类路径jar包中读取特定文件实现扩展类的载入

![](/13.png)

## loadFactories流程

![](/14.png)

# 系统初始化器解析

```java
/**
 * Callback interface for initializing a Spring {@link ConfigurableApplicationContext}
 * prior to being {@linkplain ConfigurableApplicationContext#refresh() refreshed}.
 *
 * <p>Typically used within web applications that require some programmatic initialization
 * of the application context. For example, registering property sources or activating
 * profiles against the {@linkplain ConfigurableApplicationContext#getEnvironment()
 * context's environment}. See {@code ContextLoader} and {@code FrameworkServlet} support
 * for declaring a "contextInitializerClasses" context-param and init-param, respectively.
 *
 * <p>{@code ApplicationContextInitializer} processors are encouraged to detect
 * whether Spring's {@link org.springframework.core.Ordered Ordered} interface has been
 * implemented or if the @{@link org.springframework.core.annotation.Order Order}
 * annotation is present and to sort instances accordingly if so prior to invocation.
 *
 * @author Chris Beams
 * @since 3.1
 * @param <C> the application context type
 * @see org.springframework.web.context.ContextLoader#customizeContext
 * @see org.springframework.web.context.ContextLoader#CONTEXT_INITIALIZER_CLASSES_PARAM
 * @see org.springframework.web.servlet.FrameworkServlet#setContextInitializerClasses
 * @see org.springframework.web.servlet.FrameworkServlet#applyInitializers
 */
public interface ApplicationContextInitializer<C extends ConfigurableApplicationContext> {

	/**
	 * Initialize the given application context.
	 * @param applicationContext the application to configure
	 */
	void initialize(C applicationContext);

}
```

## ApplicationContextInitializer 作用

* 上下文刷新即refresh方法前调用
* 用来编码设置一些属性变量通常用在web环境中
* 可以通过order接口进行排序

## 调用点

![](/17.png)



清除之前设置的断点：

![](/18.png)







## 调用流程

![](/16.png)

## 实现方式

* 定义在spring.factories文件中被SpringFactoriesLoader发现注册
* SpringApplication树池话完毕后手动添加
* 定义成环境变量被DelegatingApplicationContextInitializer发现注册

有个问题Order的顺序并不和最后的初始化的顺序一致