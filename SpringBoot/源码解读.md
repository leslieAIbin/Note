---
typora-root-url: /images
---

# IDEA快捷键

## 自动代码

1. Ctrl+Alt+O 优化导入的类和包
2. Alt+Insert 生成代码(如get,set方法,构造函数等) 或者右键（Generate）
3. fori/sout/psvm + Tab
4. Ctrl+Alt+T 生成try catch 或者 Alt+enter
5. CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里
6. Ctrl + O 重写方法
7. Ctrl + I 实现方法
8. Ctr+shift+U 大小写转化
9. ALT+回车 导入包,自动修正
10. ALT+/ 代码提示
11. CTRL+J 自动代码
12. Ctrl+Shift+J，整合两行为一行
13. CTRL+空格 代码提示
14. CTRL+SHIFT+SPACE 自动补全代码
15. CTRL+ALT+L 格式化代码
16. CTRL+ALT+I 自动缩进
17. CTRL+E 最近更改的代码
18. CTRL+ALT+SPACE 类名或接口名提示
19. CTRL+P 方法参数提示
20. CTRL+Q，可以看到当前方法的声明
21. Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等)
22. Ctrl+Alt+V 提取变量

## 查询快捷键

1. Ctrl＋Shift＋Backspace可以跳转到上次编辑的地
2. CTRL+ALT+ left/right 前后导航编辑过的地方
3. ALT+7 靠左窗口显示当前文件的结构
4. Ctrl+F12 浮动显示当前文件的结构
5. ALT+F7 找到你的函数或者变量或者类的所有引用到的地方
6. CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方
7. Ctrl+Shift+Alt+N 查找类中的方法或变量
8. 双击SHIFT 在项目的所有目录查找文件
9. **Ctrl+N 查找类**
10. Ctrl+Shift+N 查找文件
11. CTRL+G 定位行
12. CTRL+F 在当前窗口查找文本
13. CTRL+SHIFT+F 在指定窗口查找文本
14. CTRL+R 在 当前窗口替换文本
15. CTRL+SHIFT+R 在指定窗口替换文本
16. ALT+SHIFT+C 查找修改的文件
17. CTRL+E 最近打开的文件
18. F3 向下查找关键字出现位置
19. SHIFT+F3 向上一个关键字出现位置
20. 选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本
21. F4 查找变量来源
22. CTRL+SHIFT+O 弹出显示查找内容
23. Ctrl+W 选中代码，连续按会有其他效果
24. F2 或Shift+F2 高亮错误或警告快速定位
25. Ctrl+Up/Down 光标跳转到第一行或最后一行下
26. Ctrl+B 快速打开光标处的类或方法
27. **CTRL+ALT+B 找所有的子类** 找一个方法所有实现
28. CTRL+SHIFT+B 找变量的类
29. Ctrl+Shift+上下键 上下移动代码
30. Ctrl+Alt+ left/right 返回至上次浏览的位置
31. Ctrl+X 删除行
32. Ctrl+D 复制行
33. Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ）
34. Ctrl+H 显示类结构图
35. Ctrl+Q 显示注释文档
36. Alt+F1 查找代码所在位置
37. Alt+1 快速打开或隐藏工程面板
38. Alt+ left/right 切换代码视图
39. ALT+ ↑/↓ 在方法间快速移动定位
40. CTRL+ALT+ left/right 前后导航编辑过的地方
41. Ctrl＋Shift＋Backspace可以跳转到上次编辑的地
42. Alt+6 查找TODO

## 其他快捷键

1. SHIFT+ENTER 另起一行
2. CTRL+Z 倒退(撤销)
3. CTRL+SHIFT+Z 向前(取消撤销)
4. CTRL+ALT+F12 资源管理器打开文件夹
5. ALT+F1 查找文件所在目录位置
6. SHIFT+ALT+INSERT 竖编辑模式
7. CTRL+F4 关闭当前窗口
8. **Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义**
9. Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）

## 调试快捷键

1. alt+F8 debug时选中查看值
2. Alt+Shift+F9，选择 Debug
3. Alt+Shift+F10，选择 Run
4. Ctrl+Shift+F9，编译
5. Ctrl+Shift+F8，查看断点
6. F7，步入
7. Shift+F7，智能步入
8. Alt+Shift+F7，强制步入
9. F8，步过
10. Shift+F8，步出
11. Alt+Shift+F8，强制步过
12. Alt+F9，运行至光标处
13. Ctrl+Alt+F9，强制运行至光标处
14. F9，恢复程序
15. Alt+F10，定位到断点

## 重构

1. Ctrl+Alt+Shift+T，弹出重构菜单
2. Shift+F6，重命名
3. F6，移动
4. F5，复制
5. Alt+Delete，安全删除
6. Ctrl+Alt+N，内联

# SpringBoot 源码解读

# 项目环境准备

![](/1.png)

前端传过来的请求，会经过分发器，找到一个合适的控制器，然后会获得一个model，然后赋予给视图层，然后渲染给用户

Spring框架：



![](/2.png)

MyBatis： orm 关系型数据库 

![](/3.png)

idea创建一个ssm项目

![](/4.png)

![](/5.png)

## 直接上手SpringBoot2 + Mybatis





![](/6.png)

### pom.xml

服务器数据库5.x 就用虚拟机那个环境

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.1.7.RELEASE</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<groupId>com.example</groupId>
	<artifactId>demo</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>sb2</name>
	<description>Demo project for Spring Boot</description>

	<properties>
		<java.version>1.8</java.version>
	</properties>

	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>1.3.3</version>
		</dependency>

<!--			<dependency>-->
<!--				<groupId>mysql</groupId>-->
<!--				<artifactId>mysql-connector-java</artifactId>-->
<!--				<version>8.0.13</version>-->
<!--			</dependency>-->

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
			<exclusions>
				<exclusion>
					<groupId>org.junit.vintage</groupId>
					<artifactId>junit-vintage-engine</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.mybatis.generator</groupId>
				<artifactId>mybatis-generator-maven-plugin</artifactId>
				<version>1.3.5</version>
				<dependencies>
					<dependency>
						<groupId>mysql</groupId>
						<artifactId>mysql-connector-java</artifactId>
						<version>5.1.8</version>
					</dependency>
				</dependencies>
			</plugin>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
			</plugin>
		</plugins>
	</build>

</project>

```

一定要注意各种版本号

### generatorConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE generatorConfiguration        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"><generatorConfiguration>    <context id="testTables" targetRuntime="MyBatis3">        <commentGenerator>            <!-- 是否去除自动生成的注释 true：是 ： false:否 -->            <property name="suppressAllComments" value="true"/>        </commentGenerator>        <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->        <jdbcConnection driverClass="com.mysql.jdbc.Driver"                        connectionURL="jdbc:mysql://192.168.56.101:3306/test" userId="root"                        password="123456">        </jdbcConnection>        <!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和            NUMERIC 类型解析为java.math.BigDecimal -->        <javaTypeResolver>            <property name="forceBigDecimals" value="false"/>        </javaTypeResolver>        <!-- targetProject:生成PO类的位置 -->        <javaModelGenerator targetPackage="com.example.sb2.bean"                            targetProject="src/main/java">            <!-- enableSubPackages:是否让schema作为包的后缀 -->            <property name="enableSubPackages" value="false"/>            <!-- 从数据库返回的值被清理前后的空格 -->            <property name="trimStrings" value="true"/>        </javaModelGenerator>        <!-- targetProject:mapper映射文件生成的位置 -->        <sqlMapGenerator targetPackage="mapper"                         targetProject="src/main/resources">            <!-- enableSubPackages:是否让schema作为包的后缀 -->            <property name="enableSubPackages" value="false"/>        </sqlMapGenerator>        <!-- targetPackage：mapper接口生成的位置 -->        <javaClientGenerator type="XMLMAPPER"                             targetPackage="com.example.sb2.mapper"                             targetProject="src/main/java">            <!-- enableSubPackages:是否让schema作为包的后缀 -->            <property name="enableSubPackages" value="false"/>        </javaClientGenerator>        <!-- 指定数据库表 -->        <table schema="" tableName="demo"></table>    </context></generatorConfiguration>
```

### 属性配置

```
server.port=8080spring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://192.168.56.101:3306/test?useUnicode=true&characterEncoding=utf8&serverTimezone=GMTspring.datasource.driver-class-name=com.mysql.jdbc.Drivermybatis.mapper-locations=classpath:mapper/*.xmlmybatis.type-aliases-package=com.example.sb2.beanmybatis.configuration.map-underscore-to-camel-case=true
```

重写demo 实体类的 toString方法

### service

```java
package com.example.sb2.service;import com.example.sb2.bean.Demo;import com.example.sb2.mapper.DemoMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.util.Optional;@Componentpublic class DemoService {    @Autowired    private DemoMapper demoMapper;    public Demo getDemoById(Long id) {        return Optional.ofNullable(demoMapper.selectByPrimaryKey(id)).orElse(null);    }}
```

### 控制器

```java
package com.example.sb2.controller;import com.example.sb2.bean.Demo;import com.example.sb2.service.DemoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;import java.util.Optional;@Controller@RequestMapping("/demo")public class DemoController {    @Autowired    private DemoService demoService;    @RequestMapping("/hello/{id}")    @ResponseBody    public String hello(@PathVariable(value = "id") Long id) {        return Optional.ofNullable(demoService.getDemoById(id)).map(Demo::toString).orElse("empty String");    }}
```

### sb2搭建流程

![](/7.png)

**总结：**

耗时短

配置文件简洁

不关注版本管理

易上手

# 启动流程的介绍

https://www.cnblogs.com/theRhyme/p/11057233.html



SpringBoot2 的启动流程

一行来完成启动

```java
@SpringBootApplication@MapperScan("com.example.sb2.mapper")
public class Sb2Application {   
    public static void main(String[] args) {      
        SpringApplication.run(Sb2Application.class, args);   
    }}
```

run方法点进去  SpringApplication + run

SpringApplication 是进行一些赋值

```java
	public SpringApplication(ResourceLoader resourceLoader, Class<?>... primarySources) {
		this.resourceLoader = resourceLoader;
		Assert.notNull(primarySources, "PrimarySources must not be null");
		this.primarySources = new LinkedHashSet<>(Arrays.asList(primarySources));
		this.webApplicationType = WebApplicationType.deduceFromClasspath();
		setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
		setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
		this.mainApplicationClass = deduceMainApplicationClass();
	}	public static ConfigurableApplicationContext run(Class<?>[] primarySources, String[] args) {
		return new SpringApplication(primarySources).run(args);
	}
```

run 方法

```
public ConfigurableApplicationContext run(String... args) {
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		ConfigurableApplicationContext context = null;
		Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
		configureHeadlessProperty();
		SpringApplicationRunListeners listeners = getRunListeners(args);
		listeners.starting();
		try {
			ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);
			ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
			configureIgnoreBeanInfo(environment);
			Banner printedBanner = printBanner(environment);
			context = createApplicationContext();
			exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,
					new Class[] { ConfigurableApplicationContext.class }, context);
			prepareContext(context, environment, listeners, applicationArguments, printedBanner);
			refreshContext(context);
			afterRefresh(context, applicationArguments);
			stopWatch.stop();
			if (this.logStartupInfo) {
				new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);
			}
			listeners.started(context);
			callRunners(context, applicationArguments);
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, listeners);
			throw new IllegalStateException(ex);
		}

		try {
			listeners.running(context);
		}
		catch (Throwable ex) {
			handleRunFailure(context, ex, exceptionReporters, null);
			throw new IllegalStateException(ex);
		}
		return context;
	}
```



## 启动流程

* 框架初始化

* 框架启动

* 自动化装配

  

## 框架初始化步骤

* 加载资源 resource 读取

* 传过来的主类，一般是主类

* 1.x 环境只有两个（标准+web） 2.x多了一个reactive 环境

* 监听器用来监听关键事件

* 配置main方法所在类，一般和primarySources是一样

  

![](/8.png)

有一个计时器，项目启动之后，会在控制台上打印配置的时间

headless 实际上是就是设置系统属性java.awt.headless，在我们的例子中该属性会被设置为true，因为我们开发的是服务器程序，一般运行在没有显示器和键盘的环境。关于java中的headless模式，更多信息可以参考[这里](http://www.oracle.com/technetwork/articles/javase/headless-136834.html)。

配置上下文环境

刷新上下文：调用的是spring里的方法，加载bean

![](/9.png)

## 框架自动化装配的步骤

![](/10.png)

  ### 整体流程概览

用mindmaster来画图

这个部分图片太大了，直接用mindmaster来看

![](/11.png)

# 初始化器解析



# 系统初始化器概览

https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/testing.html#testing

* 类名：ApplicationContextInitializer

* 介绍：Spring容器刷新之前执行的一个回调函数

* 作用：向SpringBoot容器中注册属性

* 使用：继承接口自定义实现

  

# 自己动手写一个系统初始化器

idea 快速实例化的 先写上 new  对象名 ，然后 ctrl+alt+v

第一个 系统 初始化器

```java
package com.example.sb2.initializer;

import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;

import java.util.*;


// 定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序
@Order(1)
public class FirstInitializer implements
        ApplicationContextInitializer<ConfigurableApplicationContext> {

    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        // 获得环境
        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        Map<String,Object> map = new HashMap<>();
        map.put("key1", "value1");
        // map打包成一个属性
        MapPropertySource mapPropertySource = new MapPropertySource("firstInitializer", map);
        environment.getPropertySources().addLast(mapPropertySource);
        System.out.println("******** Run FirstInitializer ******** ");
    }
}

```

## meta-inf

   **为了提供存档的便签信息**，出现了Manifest.mf文件，jar文件中有一个特定的目录来存放标签信息：META-INF目录，主要应关注其中

一个名叫**manifest.mf的文件，它包含了jar文件的内容描述，在应用程序运行时向JVM提供应用程序的信息**。

关于MEATA-INF目录的作用，百度上的解释是这样的（正规的解释）：

​        **META-INF相当于一个信息包，目录中的文件和目录获得Java 2平台的认可与解释，用来配置应用程序、扩展程序、类加载器和服务manifest.mf文件，在用jar打包时自动生成。**

 

​        **jar文件都有一个默认产生的META-INF目录和其中的manifest.mf文件  使用jar命令可以直接产生META-INF目录和manifest.mf文件，**例如：



在resource文件目录下面创建 META-INF文件夹

里面创建文件夹spring.factories

该文件里写入org.springframework.context.ApplicationContextInitializer=com.example.sb2.initializer.FirstInitializer



## 创建测试服务类

```java
package com.example.sb2.service;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationContextInitializer;
import org.springframework.stereotype.Component;

@Component
public class TestService implements
        ApplicationContextAware {
    private ApplicationContext applicationContext;


    @Override
    public void setApplicationContext(ApplicationContext applicationContext)
            throws BeansException {
        this.applicationContext = applicationContext;
    }


    public String test() {
        return applicationContext.getEnvironment().getProperty("key1");
    }
}

```





## 补充知识：ApplicationContextAware

https://www.imooc.com/article/257762

http://www.pinhuba.com/spring/101049.htm

当一个类可以实现了这个接口，这个类就可以方便获得ApplicationContext中的所有bean，换句话说，就是这个类可以直接获取spring配置文件中，所有有引用到的bean对象



某个地方需要使用到ApplicationContext中的某个bean（companyService）

## 控制器





```java
package com.example.sb2.controller;

import com.example.sb2.bean.Demo;
import com.example.sb2.service.DemoService;
import com.example.sb2.service.TestService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.Optional;

@Controller
@RequestMapping("/demo")
public class DemoController {
    @Autowired
    private DemoService demoService;
    @Autowired
    private TestService testService;

    @RequestMapping("/hello/{id}")
    @ResponseBody
    public String hello(@PathVariable(value = "id") Long id) {
        return Optional.ofNullable(demoService.getDemoById(id)).map(Demo::toString).orElse("empty String");
    }


    @RequestMapping("test")
    @ResponseBody
    public String test(){
        return testService.test();
    }

}

```

运行项目  可以看到控制台里已经有打印的信息了

然后访问

http://localhost:8080/demo/test

可以返回value1



## 新建第二个初始化器

```java
package com.example.sb2.initializer;

import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;

import java.util.HashMap;
import java.util.Map;


// 定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序
@Order(2)
public class SecondInitializer implements
        ApplicationContextInitializer<ConfigurableApplicationContext> {

    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        // 获得环境
        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        Map<String,Object> map = new HashMap<>();
        map.put("key2", "value2");
        // map打包成一个属性
        MapPropertySource mapPropertySource = new MapPropertySource("secondInitializer", map);
        environment.getPropertySources().addLast(mapPropertySource);
        System.out.println("******** Run SecondInitializer ******** ");
    }
}

```

## 修改启动类

```java
package com.example.sb2.initializer;

import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;

import java.util.HashMap;
import java.util.Map;


// 定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序
@Order(2)
public class SecondInitializer implements
        ApplicationContextInitializer<ConfigurableApplicationContext> {

    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        // 获得环境
        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        Map<String,Object> map = new HashMap<>();
        map.put("key2", "value2");
        // map打包成一个属性
        MapPropertySource mapPropertySource = new MapPropertySource("secondInitializer", map);
        environment.getPropertySources().addLast(mapPropertySource);
        System.out.println("******** Run SecondInitializer ******** ");
    }
}

```

启动项目可以看到项目启动之后，控制台里成功打印信息

**@Order(xxx)** 就是bean执行的顺序  和控制台里的输出信息一致

## 第三个初始化器

```java
package com.example.sb2.initializer;

import org.springframework.context.ApplicationContextInitializer;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.core.annotation.Order;
import org.springframework.core.env.ConfigurableEnvironment;
import org.springframework.core.env.MapPropertySource;

import java.util.HashMap;
import java.util.Map;


// 定义Spring IOC容器中Bean的执行顺序的优先级，而不是定义Bean的加载顺序
@Order(3)
public class ThirdInitializer implements
        ApplicationContextInitializer<ConfigurableApplicationContext> {

    @Override
    public void initialize(ConfigurableApplicationContext applicationContext) {
        // 获得环境
        ConfigurableEnvironment environment = applicationContext.getEnvironment();
        Map<String,Object> map = new HashMap<>();
        map.put("key3", "value3");
        // map打包成一个属性
        MapPropertySource mapPropertySource = new MapPropertySource("thirdInitializer", map);
        environment.getPropertySources().addLast(mapPropertySource);
        System.out.println("******** Run ThirdInitializer ******** ");
    }
}

```

修改属性文件

```
server.port=8080
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.url=jdbc:mysql://192.168.56.101:3306/test?useUnicode=true&characterEncoding=utf8&serverTimezone=GMT
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
mybatis.mapper-locations=classpath:mapper/*.xml
mybatis.type-aliases-package=com.example.sb2.bean
mybatis.configuration.map-underscore-to-camel-case=true

# 初始化器配置
context.initializer.classes=com.example.sb2.initializer.ThirdInitializer
```

启动项目 成功初始化

但是顺序好像和Order定义的不一致，后面分析原因

******** Run ThirdInitializer ******** 
******** Run FirstInitializer ******** 
******** Run SecondInitializer ******** 

## 总结

**实现方式一：**

实现ApplicationContextInitiallizer接口

spring.factories内填写接口实现

key值为org.springframework.context.ApplicationContextInitializer

**实现方式二：**

实现ApplicationContextInitiallizer接口

SpringApplication 类初始后设置进去

**实现方式三：**

实现ApplicationContextInitiallizer接口

application.propreties内填写接口实现

key值就是context.initializer.classes

<b>注意事项</b>

都要实现ApplicationContextInitializer接口

Order值越小 越先执行

application.properties中定义的优先于其他方式

# 工厂加载机制解析（SpringFactoriesLoader）

上一节自定义初始化器是如何被spring识别并加载的呢？

idea 查找类： ctrl+n

## 介绍

可以读取源码上面的英文介绍

* 框架内部使用的通用工厂加载机制

* 从classpath下多个jar包特定的位置读取文件并初始化类

* 文件内容必须是kv形式，即properties类型

* key是全限定名（抽象类|接口），value是实现，多个实现用，分割

  

![](/8.png)

在配置系统初始化器的时候就已经调用SpringFatoriesLoader加载了bean

先把启动类里面 新加的自定义初始化器的代码全注释了，恢复到原来的样子

![](/12.png)

```
	setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));
```

```java
	private <T> Collection<T> getSpringFactoriesInstances(Class<T> type, Class<?>[] parameterTypes, Object... args) {
		ClassLoader classLoader = getClassLoader();
		// Use names and ensure unique to protect against duplicates
        /// 调用SpringFactoriesLoader类加载spring.factories文件
		Set<String> names = new LinkedHashSet<>(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
        //  
        // 实例化获取到的类实例
		List<T> instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
        // 对结果进行排序
		AnnotationAwareOrderComparator.sort(instances);
		return instances;
	}
```

```
public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
```

![](/15.png)

不断打断点，然后点击蓝色框中的运行箭头

ctrl+n 搜索spring.factories  勾选上include non-project files

有很多的spring.factories 

## SpringFactoriesLoader作用：

springboot框架从类路径jar包中读取特定文件实现扩展类的载入

![](/13.png)

## loadFactories流程

![](/14.png)

# 系统初始化器解析

```java
/**
 * Callback interface for initializing a Spring {@link ConfigurableApplicationContext}
 * prior to being {@linkplain ConfigurableApplicationContext#refresh() refreshed}.
 *
 * <p>Typically used within web applications that require some programmatic initialization
 * of the application context. For example, registering property sources or activating
 * profiles against the {@linkplain ConfigurableApplicationContext#getEnvironment()
 * context's environment}. See {@code ContextLoader} and {@code FrameworkServlet} support
 * for declaring a "contextInitializerClasses" context-param and init-param, respectively.
 *
 * <p>{@code ApplicationContextInitializer} processors are encouraged to detect
 * whether Spring's {@link org.springframework.core.Ordered Ordered} interface has been
 * implemented or if the @{@link org.springframework.core.annotation.Order Order}
 * annotation is present and to sort instances accordingly if so prior to invocation.
 *
 * @author Chris Beams
 * @since 3.1
 * @param <C> the application context type
 * @see org.springframework.web.context.ContextLoader#customizeContext
 * @see org.springframework.web.context.ContextLoader#CONTEXT_INITIALIZER_CLASSES_PARAM
 * @see org.springframework.web.servlet.FrameworkServlet#setContextInitializerClasses
 * @see org.springframework.web.servlet.FrameworkServlet#applyInitializers
 */
public interface ApplicationContextInitializer<C extends ConfigurableApplicationContext> {

	/**
	 * Initialize the given application context.
	 * @param applicationContext the application to configure
	 */
	void initialize(C applicationContext);

}
```

## ApplicationContextInitializer 作用

* 上下文刷新即refresh方法前调用
* 用来编码设置一些属性变量通常用在web环境中
* 可以通过order接口进行排序

## 调用点

![](/17.png)



清除之前设置的断点，点‘-’

![](/18.png)

![](/19.png)



```java
	/**
	 * Apply any {@link ApplicationContextInitializer}s to the context before it is
	 * refreshed.
	 * @param context the configured ApplicationContext (not refreshed yet)
	 * @see ConfigurableApplicationContext#refresh()
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	protected void applyInitializers(ConfigurableApplicationContext context) {
		for (ApplicationContextInitializer initializer : getInitializers()) {
			Class<?> requiredType = GenericTypeResolver.resolveTypeArgument(initializer.getClass(),
					ApplicationContextInitializer.class);
			Assert.isInstanceOf(requiredType, context, "Unable to call initializer.");
			initializer.initialize(context);
		}
	}
```



```java
	/**
	 * Returns read-only ordered Set of the {@link ApplicationContextInitializer}s that
	 * will be applied to the Spring {@link ApplicationContext}.
	 * @return the initializers
	 */
	public Set<ApplicationContextInitializer<?>> getInitializers() {
		return asUnmodifiableOrderedSet(this.initializers);
	}
```

前面提过，initializer方法 在 new SpringApplication方法中的springfactoriesloader已经加载了 注入到了initializers属性中

```java
	/**
	 * Sets the {@link ApplicationContextInitializer} that will be applied to the Spring
	 * {@link ApplicationContext}.
	 * @param initializers the initializers to set
	 */
	public void setInitializers(Collection<? extends ApplicationContextInitializer<?>> initializers) {
		this.initializers = new ArrayList<>();
		this.initializers.addAll(initializers);
	}
```

 ```java
	// 判断泛型类型 一定是子类才会调用
	Assert.isInstanceOf(requiredType, context, "Unable to call initializer.");
 ```

**查看initializer.initialize(context); 中 initialize方法的实现， ctrl+alt+b**

所有方法的实现

感觉**applicationContext**是一个很重要的变量

设置断点 

![](/20.png)

通过自己实现的初始化器类，项Spring中输入了属性



以上是实现方式一的原理



**方式二：**

![](/21.png)

在 new SpringApplication中已经用SpingFactoriesLoader这个类加载了spring.factory文件中的属性， 所以方式一比方式二要先执行

```java
	/**
	 * Add {@link ApplicationContextInitializer}s to be applied to the Spring
	 * {@link ApplicationContext}.
	 * @param initializers the initializers to add
	 */
	public void addInitializers(ApplicationContextInitializer<?>... initializers) {
		this.initializers.addAll(Arrays.asList(initializers));
	}
```

![](/22.png)

总结一下，方式二是采用的硬编码，直接加入了自定义初始化器类



接下来来看一下第三种方式，恢复启动类的注释，恢复到原来的样子

**方式三**

第三种方式是通过 属性配置文件来完成

```
DelegatingApplicationContextInitializer
```

也是系统初始化器的一个实现，

这个类被定义在了Spring.factories （ctrl+n 勾选include non-project files)





![](/23.png)

被SpringFactoriesLoader给加载

```
private int order = 0;
```

因为DelegatingApplicationContextInitializer 的 order = 0 所以最先加进来

图示：

![](/24.png)

![](/25.png)



![](/26.png)

因为order=0 ，所以delegating。。。的初始化方法最先被调用




![](/27.png)



```java
private Class<?> getInitializerClass(String className) throws LinkageError {
		try {
			Class<?> initializerClass = ClassUtils.forName(className, ClassUtils.getDefaultClassLoader());
			Assert.isAssignable(ApplicationContextInitializer.class, initializerClass);
			return initializerClass;
		}
		catch (ClassNotFoundException ex) {
			throw new ApplicationContextException("Failed to load context initializer class [" + className + "]", ex);
		}
	}

```



判断这个类是不是ApplicationContextInitializer的一个子类



![](/28.png)







因为initiallizerClasses不为空

```java
private void applyInitializerClasses(ConfigurableApplicationContext context, List<Class<?>> initializerClasses) {
		Class<?> contextClass = context.getClass();
		List<ApplicationContextInitializer<?>> initializers = new ArrayList<>();
		for (Class<?> initializerClass : initializerClasses) {
			initializers.add(instantiateInitializer(contextClass, initializerClass));
		}
		applyInitializers(context, initializers);
	}

```



**instantiateInitializer**

通过BeanUtils.instantiateClass(initializerClass);来初始化这个类 和 SpringFactoriesLoader相似







## 调用流程



![](/16.png)

## 实现方式

* 定义在spring.factories文件中被SpringFactoriesLoader发现注册
* SpringApplication树池话完毕后手动添加
* 定义成环境变量被DelegatingApplicationContextInitializer发现注册

有个问题Order的顺序并不和最后的初始化的顺序一致

# 系统初始化器总结

三种自定义初始化器注入的实现

* 功能作用 ：springboot的回调接口，向springboot容器中注册一些属性，功能
* 注意事项：order，环境变量是最优先的
* 实现方式：三种方式 环境变量、新建文件、硬编码
* 实现原理：SpringFactoriesLoader  硬编码  BeanUtils.instantiateClass(initializerClass);

## 调用机制回顾

![](/29.png)

有多个实现，连接在一起，

springfactoriesloader载入，成为springboot的initializer属性

运行的时候，会依次调用initializer的initializers属性

完成向容器里注册属性

## 面试题

* 介绍一下SpringFactoriesLoader?

  工厂加载类，扩展点实现的载入

* SpringFactoriesLoader如何加载工厂类？

  读取指定路径下的指定文件，把他们读取成properties对象，依次去遍历文件内容，组装成类名以及对应的实现，依次遍历 通过order进行排序

  

* 系统初始化器的作用

  sb容器的一个回调接口，通过它向容器定义我们的属性

* 系统初始化器调用的实际

  run方法中的prepareContext中调用，

* 如何自定义实现系统初始化器？

  三种实现方式，每一种实现方式不同，推荐使用第一种

* 注意事项

  order排序 及其失效问题

---



补充：

通过上面三种实现方式可以看出

- 都要实现ApplicationContextInitializer接口
- Order值越小越先执行
- application.yml中定义的优先于其它方式

实现原理总结：

- 定义在spring.factories文件中被SpringFactoriesLoader发现注册（第一种）
- SpringApplication初始化完成后手动添加（第二种）
- 定义成环境变量被DelegatingApplicationContextInitializer发现注册（第三种）这就是ApplicationContextInitializer的三种实现方式，那么spring容器是怎么识别并注入它们的呢？是通过SpringFactoriesLoader



SpringFactoriesLoader介绍

首先我们来看下官方是怎么描述它的：该类是一个框架内部使用的通用工厂装载机制，SpringFactoriesLoader 加载和实例化给定类型的工厂“META-INF / spring.factories”文件，其可存在于在类路径多个JAR文件。该spring.factories文件必须为Properties格式，其中的关键是接口或抽象类的的名称必须是全限定名并且值是一个逗号分隔（多个的情况）的实现类名的列表。（英文不是很好，翻译可能读起来有点怪不准确）

总结一下

- SpringFactoriesLoader是框架内部使用的的通用工厂加载机制
- 从从classpath下多个jar包特定位置读取文件并初始化类
- 文件内容必学是kv形式（properties类型）
- key是全限定名（抽象类或者接口），value是实现类名，如果多个实现类，用逗号分隔

由以上源码可以看出SpringFactories的工作流程是：首先在缓存中进行查找，如果缓存中存在，则直接返回缓存中的全路径类名，完成实例化排序。如果不存在，先读取指定资源，构建Properties，获取kv值，并将value值按逗号分隔，把结果保存到缓存中，后一次实例化这些对象，对实例化后的对象进行排序。

四：ApplicationContextInitializer调用

上面讲了是springboot是如何识别并注册系统初始化器的，那么它是在什么时候调用系统初始化器呢？因为系统初始化器是spring容器刷新之前执行的一个回调函数。结合上一章springboot的启动流程可知，它应该是在框架启动中，刷新上下文之前执行的。可以看下源码

ApplicationContextInitializer调用总结

- run框架启动
- prepareContext方法中调用applyInitializers方法
- 遍历调用初始化器进行判断

# 监听器设计模式介绍

![](/30.png)

 某个节点通过广播器发布一些信息，有一些监听器听见了会触发执行一些动作。

监听器模式有三个要素 —— **广播器、事件、监听器**

广播器：用于事件注册和广播
事件：触发的操作
监听器：监听器模式的核心，定义事件发生后的动作

# 动手实现监听器设计模式

建立一个event的包，代码全放在这个包里



声明一个天气事件的抽象类

```
package com.example.sb2.event;

public abstract class WeatherEvent {
    public abstract String getWeather();
}

```



定义两个天气事件

```
package com.example.sb2.event;

public class SnowEvent extends WeatherEvent{
    @Override
    public String getWeather() {
        return "snow";
    }
}

```





```
package com.example.sb2.event;

public class RainEvent extends WeatherEvent{
    @Override
    public String getWeather() {
        return "rain";
    }
}

```

声明天气监听器接口

```
package com.example.sb2.event;

public interface WeatherListener {
    void onWeatherEvent(WeatherEvent event);
    
}

```





实现两个天气监听器

```
package com.example.sb2.event;

public class SnowListener implements WeatherListener{
    @Override
    public void onWeatherEvent(WeatherEvent event) {
        if (event instanceof SnowEvent){
            System.out.println("hello"+event.getWeather());
        }
        
    }
}

```





```
package com.example.sb2.event;

public class RainListener implements WeatherListener{
    @Override
    public void onWeatherEvent(WeatherEvent event) {
        if (event instanceof RainEvent){
            System.out.println("hello"+event.getWeather());
        }
    }
}

```



定义一个广播器的接口

```
package com.example.sb2.event;

public interface EventMulticaster {
    // 广播事件
    void multicastEvent(WeatherEvent event);

    // 添加监听器
    void addListener(WeatherListener weatherListener);

    // 删除监听器
    void removeListener(WeatherListener event);

}

```





实现广播器的接口

```
package com.example.sb2.event;

import java.util.ArrayList;
import java.util.List;

public abstract class AbstractEventMulticaster implements EventMulticaster{

    private List<WeatherListener> listeners = new ArrayList<>();

    @Override
    public void multicastEvent(WeatherEvent event) {
        // 开始广播
        doStart();
        // 遍历监听器，播放监听事件
        listeners.forEach(i -> i.onWeatherEvent(event));
        // 广播结束
        doEnd();
    }

    abstract void doStart();
    abstract void doEnd();

    @Override
    public void addListener(WeatherListener weatherListener) {
        listeners.add(weatherListener);
    }

    @Override
    public void removeListener(WeatherListener weatherListener) {
        listeners.remove(weatherListener);
    }
}

```



定义一个天气的广播器

```java
package com.example.sb2.event;

public class WeatherEventMulticaster extends AbstractEventMulticaster{
    @Override
    void doStart() {
        System.out.println("开始广播");
    }

    @Override
    void doEnd() {
        System.out.println("结束广播");
    }
}

```



触发机制 测试类

```java
package com.example.sb2.event;

public class Test {
    public static void main(String[] args){
        // 首先构造广播器
        WeatherEventMulticaster eventMulticaster = new WeatherEventMulticaster();
        // 构造监听器
        RainListener rainListener = new RainListener();
        SnowListener snowListener = new SnowListener();
        // 添加监听器到广播器中
        eventMulticaster.addListener(rainListener);
        eventMulticaster.addListener(snowListener);
        // 通过广播器发送下雪事件
        eventMulticaster.multicastEvent(new SnowEvent());
        eventMulticaster.multicastEvent(new RainEvent());
        // 移除监听器
        eventMulticaster.removeListener(snowListener);
        // 继续发送事件
        eventMulticaster.multicastEvent(new SnowEvent());
        eventMulticaster.multicastEvent(new RainEvent());
    }
}

```



控制台输出结果

开始广播
hellosnow
结束广播
开始广播
hellorain
结束广播
开始广播
结束广播
开始广播
hellorain
结束广播

## 监听器模式要素

* 事件

* 监听器

* 广播器

* 触发机制

  

# SpringBoot监听器实现

## 系统监听器介绍

ctrl+n 查找类

```java
/*
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.context;

import java.util.EventListener;

/**
 * Interface to be implemented by application event listeners.
 * Based on the standard {@code java.util.EventListener} interface
 * for the Observer design pattern.
 *
 * <p>As of Spring 3.0, an ApplicationListener can generically declare the event type
 * that it is interested in. When registered with a Spring ApplicationContext, events
 * will be filtered accordingly, with the listener getting invoked for matching event
 * objects only.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @param <E> the specific ApplicationEvent subclass to listen to
 * @see org.springframework.context.event.ApplicationEventMulticaster
 */
@FunctionalInterface
public interface ApplicationListener<E extends ApplicationEvent> extends EventListener {

	/**
	 * Handle an application event.
	 * @param event the event to respond to
	 */
	void onApplicationEvent(E event);

}

```

```
@FunctionalInterface
```

功能接口只能有一个方法

## 系统广播器介绍

查找类 ctrl+n

```java
/*
 * Copyright 2002-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.springframework.context.event;

import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.core.ResolvableType;
import org.springframework.lang.Nullable;

/**
 * Interface to be implemented by objects that can manage a number of
 * {@link ApplicationListener} objects, and publish events to them.
 *
 * <p>An {@link org.springframework.context.ApplicationEventPublisher}, typically
 * a Spring {@link org.springframework.context.ApplicationContext}, can use an
 * ApplicationEventMulticaster as a delegate for actually publishing events.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @author Stephane Nicoll
 */
public interface ApplicationEventMulticaster {

	/**
	 * Add a listener to be notified of all events.
	 * @param listener the listener to add
	 */
	void addApplicationListener(ApplicationListener<?> listener);

	/**
	 * Add a listener bean to be notified of all events.
	 * @param listenerBeanName the name of the listener bean to add
	 */
	void addApplicationListenerBean(String listenerBeanName);

	/**
	 * Remove a listener from the notification list.
	 * @param listener the listener to remove
	 */
	void removeApplicationListener(ApplicationListener<?> listener);

	/**
	 * Remove a listener bean from the notification list.
	 * @param listenerBeanName the name of the listener bean to add
	 */
	void removeApplicationListenerBean(String listenerBeanName);

	/**
	 * Remove all listeners registered with this multicaster.
	 * <p>After a remove call, the multicaster will perform no action
	 * on event notification until new listeners are being registered.
	 */
	void removeAllListeners();

	/**
	 * Multicast the given application event to appropriate listeners.
	 * <p>Consider using {@link #multicastEvent(ApplicationEvent, ResolvableType)}
	 * if possible as it provides a better support for generics-based events.
	 * @param event the event to multicast
	 */
	void multicastEvent(ApplicationEvent event);

	/**
	 * Multicast the given application event to appropriate listeners.
	 * <p>If the {@code eventType} is {@code null}, a default type is built
	 * based on the {@code event} instance.
	 * @param event the event to multicast
	 * @param eventType the type of event (can be null)
	 * @since 4.2
	 */
	void multicastEvent(ApplicationEvent event, @Nullable ResolvableType eventType);

}

```

## 系统事件介绍

研究一下idea uml

![](/31.png)

## 事件发送顺序

![](/32.png)

https://zhuanlan.zhihu.com/p/80912015 这篇文章里面介绍到了事件发送顺序

环境准备好了的意思是：已经将一些属性注入到了springboot的容器中。

在加载任何bean之前 准备好上下文

准备：应用上下文已经加载完毕，但是bean没有加载完成

started：sb2已经把单例的bean实例化完成了  `ApplicationRunner` 和 `CommandLineRunner` 运行程序之前。



ready:`ApplicationRunner` 和 `CommandLineRunner`已经完成调用了，也意味着 `SpringBoot` 加载已经完成。



## 监听器注册

```
setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
```

getSpringFactoriesInstances 加载linstener的实现类

先获取类名

依次实例化

排序

和之前的初始化器注册流程其实差不多

![](/33.png)

## 监听事件触发机制

https://www.cnblogs.com/linlf03/p/12274452.html

run方法 关键节点会发送关键事件

```java
	StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		ConfigurableApplicationContext context = null;
		Collection<SpringBootExceptionReporter> exceptionReporters = new ArrayList<>();
		configureHeadlessProperty();
		SpringApplicationRunListeners listeners = getRunListeners(args);
		listeners.starting();
```

先来看listeners.starting()

```
public void starting() {
		for (SpringApplicationRunListener listener : this.listeners) {
			listener.starting();
		}
	}

```

调用的是SpringApplicationRunListener 的starting()方法

SpringApplicationRunListener  定义了不同阶段的事件

在 ctrl+alt+b查看SpringApplicationRunListener 的starting()实现类

```java
	@Override
	public void starting() {
		this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));
	}

```

用了一个广播器，发送了一个ApplicationStartingEvent的事件

**springboot监听器的内部实现和外部调用隔离开来**

不需要构造事件，我们之前的例子是要自己构造事件的

改造之前的例子

把类的实现放在一个类的里面，外部调用只需要调用这个类的接口

```java
package com.example.sb2.event;

import org.springframework.stereotype.Component;
// 方便注入
@Component
public class WeatherEventMulticaster extends AbstractEventMulticaster{
    @Override
    void doStart() {
        System.out.println("开始广播");
    }

    @Override
    void doEnd() {
        System.out.println("结束广播");
    }
}

```





```
package com.example.sb2.event;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class WeatherRunListener {
    @Autowired
    private WeatherEventMulticaster weatherEventMulticaster;


    public void snow() {
        weatherEventMulticaster.multicastEvent(new SnowEvent());
    }

    public void rain(){
        weatherEventMulticaster.multicastEvent(new RainEvent());
    }
}

```

所有自己的写的文件里面都要加入@Component

```
package com.example.sb2.event;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;

@Component
public abstract class AbstractEventMulticaster implements EventMulticaster{

//    private List<WeatherListener> listeners = new ArrayList<>();

    @Autowired
    private List<WeatherListener> listeners;
    
    @Override
    public void multicastEvent(WeatherEvent event) {
        // 开始广播
        doStart();
        // 遍历监听器，播放监听事件
        listeners.forEach(i -> i.onWeatherEvent(event));
        // 广播结束
        doEnd();
    }

    abstract void doStart();
    abstract void doEnd();

    @Override
    public void addListener(WeatherListener weatherListener) {
        listeners.add(weatherListener);
    }

    @Override
    public void removeListener(WeatherListener weatherListener) {
        listeners.remove(weatherListener);
    }
}

```



边写测试类，在sb2的单元测试里面修改

```java
package com.example.sb2;

import com.example.sb2.event.WeatherRunListener;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.context.web.WebAppConfiguration;

@RunWith(SpringRunner.class)
@SpringBootTest
@WebAppConfiguration
public class Sb2ApplicationTests {

	@Autowired
	private WeatherRunListener weatherRunListener;


	@Before
	public void init() {
		System.out.println("开始测试-----------------");
	}

	@After
	public void after() {
		System.out.println("测试结束-----------------");
	}


	@Test
	public void testEvent() {
		weatherRunListener.rain();
		weatherRunListener.snow();
	}
}

```

**低耦合，高内聚**

```java
@Override
	public void starting() {
		this.initialMulticaster.multicastEvent(new ApplicationStartingEvent(this.application, this.args));
	}
```



看一下**multicastEvent**这个方法

```
// 获得事件class的一个包装
resolveDefaultEventType
```

```java
@Override
	public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
		ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
		// 获得线程池
		Executor executor = getTaskExecutor();
		for (ApplicationListener<?> listener : getApplicationListeners(event, type)) {
			if (executor != null) {
				executor.execute(() -> invokeListener(listener, event));
			}
			else {
				invokeListener(listener, event);
			}
		}
	}
```

```
getApplicationListeners
```

获得当前感兴趣的监听器列表j

```java
protected Collection<ApplicationListener<?>> getApplicationListeners(
			ApplicationEvent event, ResolvableType eventType) {

        // 获得事件的来源，来源就是SpringApplication 
		Object source = event.getSource();
		Class<?> sourceType = (source != null ? source.getClass() : null);
        // 如果已经在缓存中存在感兴趣的监听器，直接返回
		ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType);

		
		ListenerRetriever retriever = this.retrieverCache.get(cacheKey);
		if (retriever != null) {
			return retriever.getApplicationListeners();
		}

		if (this.beanClassLoader == null ||
				(ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &&
						(sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) {
			// Fully synchronized building and caching of a ListenerRetriever
            // 同步方法
			synchronized (this.retrievalMutex) {
                // 其他线程有没有完成，
				retriever = this.retrieverCache.get(cacheKey);
				if (retriever != null) {
					return retriever.getApplicationListeners();
				}
				retriever = new ListenerRetriever(true);
				Collection<ApplicationListener<?>> listeners =
						retrieveApplicationListeners(eventType, sourceType, retriever);
				this.retrieverCache.put(cacheKey, retriever);
				return listeners;
			}
		}
		else {
			// No ListenerRetriever caching -> no synchronization necessary
			return retrieveApplicationListeners(eventType, sourceType, null);
		}
	}

```

retrieveApplicationListeners

```java
	private Collection<ApplicationListener<?>> retrieveApplicationListeners(
			ResolvableType eventType, @Nullable Class<?> sourceType, @Nullable ListenerRetriever retriever) {

		List<ApplicationListener<?>> allListeners = new ArrayList<>();
		Set<ApplicationListener<?>> listeners;
		Set<String> listenerBeans
            // 标记为同步方法，防止多线程进入
		synchronized (this.retrievalMutex) {
            // 默认监听器 一部分为容器中已经存在的监听器，一部分是监听器bean的字符串标识的名称
            // applicationListenerBeans主要为了处理那些声明后还是还没有被添加进监听器集合中的bean。
            // 从spring.factories 加载进十个默认监听器
			listeners = new LinkedHashSet<>(this.defaultRetriever.applicationListeners);
			listenerBeans = new LinkedHashSet<>(this.defaultRetriever.applicationListenerBeans);
		}
		for (ApplicationListener<?> listener : listeners) {
            // 是不是对当前事件感兴趣 ，如果感兴趣就加入集合
			if (supportsEvent(listener, eventType, sourceType)) {
				if (retriever != null) {
					retriever.applicationListeners.add(listener);
				}
				allListeners.add(listener);
			}
		}
		if (!listenerBeans.isEmpty()) {
			BeanFactory beanFactory = getBeanFactory();
			for (String listenerBeanName : listenerBeans) {
				try {
					Class<?> listenerType = beanFactory.getType(listenerBeanName);
					if (listenerType == null || supportsEvent(listenerType, eventType)) {
						ApplicationListener<?> listener =
								beanFactory.getBean(listenerBeanName, ApplicationListener.class);
						if (!allListeners.contains(listener) && supportsEvent(listener, eventType, sourceType)) {
							if (retriever != null) {
								if (beanFactory.isSingleton(listenerBeanName)) {
									retriever.applicationListeners.add(listener);
								}
								else {
									retriever.applicationListenerBeans.add(listenerBeanName);
								}
							}
							allListeners.add(listener);
						}
					}
				}
				catch (NoSuchBeanDefinitionException ex) {
					// Singleton listener instance (without backing bean definition) disappeared -
					// probably in the middle of the destruction phase
				}
			}
		}
        // 对监听器进行排序
		AnnotationAwareOrderComparator.sort(allListeners);
		if (retriever != null && retriever.applicationListenerBeans.isEmpty()) {
			retriever.applicationListeners.clear();
			retriever.applicationListeners.addAll(allListeners);
		}
		return allListeners;
	}
// 通过以上代码来获得对当前事件感兴趣的监听器

```





```JAVA
	protected boolean supportsEvent(
			ApplicationListener<?> listener, ResolvableType eventType, @Nullable Class<?> sourceType) {

		GenericApplicationListener smartListener = (listener instanceof GenericApplicationListener ?
				(GenericApplicationListener) listener : new GenericApplicationListenerAdapter(listener));
		return (smartListener.supportsEventType(eventType) && smartListener.supportsSourceType(sourceType));
	}
	
```





![](/34.png)

```

ConfigFileApplicationListener 并不是子类
```

所以进入

```java
GenericApplicationListenerAdapter
	public GenericApplicationListenerAdapter(ApplicationListener<?> delegate) {
		Assert.notNull(delegate, "Delegate listener must not be null");
		this.delegate = (ApplicationListener<ApplicationEvent>) delegate;
		// 获得感兴趣的事件类型
		this.declaredEventType = resolveDeclaredEventType(this.delegate);
	}
	
```

代理类 this.delegate...



```
resolveDeclaredEventType  泛型解析方法
```

当前监听器对哪个事件感兴趣

由于

```java
public interface SmartApplicationListener extends ApplicationListener<ApplicationEvent>, Ordered {
```

ApplicationEvent的原因



```java
return (smartListener.supportsEventType(eventType) && smartListener.supportsSourceType(sourceType));
判断是否支持该事件
```





```java
@Override
	@SuppressWarnings("unchecked")
	public boolean supportsEventType(ResolvableType eventType) {
        // 当前这个类是不是 SmartApplicationListener
        //ConfigFileApplicationListener
		if (this.delegate instanceof SmartApplicationListener) {
			Class<? extends ApplicationEvent> eventClass = (Class<? extends ApplicationEvent>) eventType.resolve();
			return (eventClass != null && ((SmartApplicationListener) this.delegate).supportsEventType(eventClass));
		}
		else {
			return (this.declaredEventType == null || this.declaredEventType.isAssignableFrom(eventType));
		}
	}
```



实现类的supportsEventType

```
	@Override
	public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
		return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType)
				|| ApplicationPreparedEvent.class.isAssignableFrom(eventType);
	}

```

如果返回false，就说明对该事件不感兴趣



这一块还需要再看一遍







### 流程图

https://blog.csdn.net/qq330983778/article/details/99762511

https://www.cnblogs.com/linlf03/p/12274452.html

获取监听器列表

![](/35.png)

通用触发条件

![](/36.png)



## 自定义监听器



```java
package com.example.sb2.listener;

import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.boot.context.event.ApplicationStartingEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.core.annotation.Order;


@Order(1)
public class FirstListener implements ApplicationListener<ApplicationStartedEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) {
        System.out.println("hello, first listener");
    }
}

```



在spring.factories文件中

```
org.springframework.context.ApplicationContextInitializer=com.example.sb2.initializer.FirstInitializer


org.springframework.context.ApplicationListener=com.example.sb2.listener.FirstListener

```



启动项目，控制台里有相应的输出  这种方式就是springFatoriesLoader来加载相应的属性



第二种自定义监听器的方式

```java
package com.example.sb2.listener;


import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.core.annotation.Order;


@Order(2)
public class SecondListener implements ApplicationListener<ApplicationStartedEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) {
        System.out.println("hello, second listener");
    }
}

```



修改启动类

```java
package com.example.sb2;

import com.example.sb2.initializer.SecondInitializer;
import com.example.sb2.listener.SecondListener;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan("com.example.sb2.mapper")
public class Sb2Application {

	public static void main(String[] args) {
//		SpringApplication.run(Sb2Application.class, args);

//		// ctrl + alt + v 快速实例化
//		SpringApplication springApplication = new SpringApplication(Sb2Application.class);
//		// 添加系统初始化器
//		springApplication.addInitializers(new SecondInitializer());
//		springApplication.run(args);


		// 自定义监听器
		SpringApplication springApplication = new SpringApplication(Sb2Application.class);
		springApplication.addListeners(new SecondListener());
		springApplication.run(args);
	}
}

```



其实和之前学习的自定义初始化器差不多



第三种自定义监听器

```java
package com.example.sb2.listener;


import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.core.annotation.Order;

@Order(3)
public class ThirdListener implements ApplicationListener<ApplicationStartedEvent> {
    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) {
        System.out.println("hello, third listener");
    }
}

```





在application属性配置文件中加入

```java
server.port=8080
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.url=jdbc:mysql://192.168.56.101:3306/test?useUnicode=true&characterEncoding=utf8&serverTimezone=GMT
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
mybatis.mapper-locations=classpath:mapper/*.xml
mybatis.type-aliases-package=com.example.sb2.bean
mybatis.configuration.map-underscore-to-camel-case=true


context.initializer.classes=com.example.sb2.initializer.ThirdInitializer
context.listener.classes=com.example.sb2.listener.ThirdListener
```



启动项目，第三个自定义监听器还是最先被加载进来的  原理应该是和前面的一样的

```
DelegatingApplicationListener里order被定义成了0
```



第四种自定义监听器被加载的方式

SmartApplicationListener

https://blog.csdn.net/noaman_wgs/article/details/102811177



```
package com.example.sb2.listener;

import org.springframework.boot.context.event.ApplicationPreparedEvent;
import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.event.SmartApplicationListener;
import org.springframework.core.annotation.Order;


public class FourthListener implements SmartApplicationListener {
    @Override
    public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
        return ApplicationStartedEvent.class.isAssignableFrom(eventType) ||
                ApplicationPreparedEvent.class.isAssignableFrom(eventType);
    }

    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        System.out.println("hello, fourth listener");
    }
}
package com.example.sb2.listener;

import org.springframework.boot.context.event.ApplicationPreparedEvent;
import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.event.SmartApplicationListener;
import org.springframework.core.annotation.Order;


public class FourthListener implements SmartApplicationListener {
    @Override
    public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
        return ApplicationStartedEvent.class.isAssignableFrom(eventType) ||
                ApplicationPreparedEvent.class.isAssignableFrom(eventType);
    }

    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        System.out.println("hello, fourth listener");
    }
}

```



在spring.factories文件中追加

```
org.springframework.context.ApplicationContextInitializer=com.example.sb2.initializer.FirstInitializer


org.springframework.context.ApplicationListener=com.example.sb2.listener.FirstListener,com.example.sb2.listener.FourthListener

```

启动控制台

第四个监听器被加入进去





实现ApplicationListener接口对单一事件监听

实现SmartApplicationListener接口针对多个事件进行监听

Order值越小的话，越先被执行

通过application.properties中定义的方式会优先于其他方式执行



## 面试题

```
SpringApplicationRunListener
```

用来隔离监听器内部实现和容器调用

在关键节点调用类，不需要感知内部做了什么事情

* 监听器模式：原理图、三要素

* 监听器相关的实现类有哪些。

* 有哪些框架事件以及他们的顺序

* 介绍监听事件触发机制

* 如何自定义实现系统监听器及注意事项

* 实现ApplicationListener接口（某一类）和SmartApplicationListener（指定多类）接口区别

  

# Bean解析

* IOC思想

* XML方式配置bean

* 注解方式配置bean

* refresh方法（spring里的核心方法）

* bean实例化

  

## IOC思想

![](/37.png)



这几个对象相互依赖

在一个类里调用另外的类 早期的java需要手动new 这个对象

举例说明，假设有一个animal类有两个实现Dog cat

如果实现类变了，要去手动修改，

Animal animal = new Dog();

Animal animal = new Cat();

用了spring 

@Autowired

Animal animal; 不用关注它内部的实现

![](/38.png)

使用一个装置，将四个容器隔离开来。

不需要让每个容器知道对方的存在  通过中间的容器带动大家一起运行。

去掉中间的容器，四个容器感知不到其他容器的存在，耦合性降低

## IOC优点

* 松耦合 感知不到对方的存在

* 灵活性 不需要在类中去调用使用类的构造函数

* 可维护性  可以知道哪个地方用到了animal类

  

## Bean配置方式

* xml
* 注解

## xml方式配置bean

* 无参构造

* 有参构造

* 静态工厂方法

* 实例工厂方法

  



定义student类

```java
package com.example.sb2.IOC.xml;

import java.util.List;

public class Studeng {
    private String name;

    private int age;

    private List<String> classList;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public List<String> getClassList() {
        return classList;
    }

    public void setClassList(List<String> classList) {
        this.classList = classList;
    }

    @Override
    public String toString() {
        return "Studeng{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", classList=" + String.join(",", classList) +
                '}';
    }
}

```



在resources 下创建ioc目录 ，创建demo.xml文件

```xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="student" class="com.example.sb2.IOC.xml.Student">
        <property name="name" value="zhangsan"/>
        <property name="age" value="13"/>
        <property name="classList" >
            <list>
                <value>math</value>
                <value>english</value>
            </list>
        </property>
    </bean>
</beans>

```



定义服务类

```java
package com.example.sb2.IOC.xml;

public class HelloService {
    private Student student;

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public  String hello() {
        return student.toString();
    }
}

```



xml 定义属性

```xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="student" class="com.example.sb2.IOC.xml.Student">
        <property name="name" value="zhangsan"/>
        <property name="age" value="13"/>
        <property name="classList" >
            <list>
                <value>math</value>
                <value>english</value>
            </list>
        </property>
    </bean>

    <bean id="helloService" class="com.example.sb2.IOC.xml.HelloService">
        <property name="student" ref="student" />
    </bean>

</beans>

```



测试类

```java
package com.example.sb2;

import com.example.sb2.IOC.xml.HelloService;
import com.example.sb2.event.WeatherRunListener;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.context.web.WebAppConfiguration;

@RunWith(SpringRunner.class)
@SpringBootTest
@WebAppConfiguration
@ContextConfiguration(locations = "classpath:ioc/demo.xml")
public class Sb2ApplicationTests {

	@Autowired
	private HelloService helloService;


	@Test
	public void testHello() {
		System.out.println(helloService.hello());
	}

//	@Autowired
//	private WeatherRunListener weatherRunListener;

//
//	@Before
//	public void init() {
//		System.out.println("开始测试-----------------");
//	}
//
//	@After
//	public void after() {
//		System.out.println("测试结束-----------------");
//	}
//
//
//	@Test
//	public void testEvent() {
//		weatherRunListener.rain();
//		weatherRunListener.snow();
//	}


}

```

启动测试类，student信息被注入了

这是第一个例子-无参构造



有参构造注入

Student类 有参构造

```
  public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

```



修改xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="student" class="com.example.sb2.IOC.xml.Student">
        <constructor-arg index="0" value="zhangsan" />
        <constructor-arg index="1" value="13" />
<!--        <property name="name" value="zhangsan"/>-->
<!--        <property name="age" value="13"/>-->
        <property name="classList" >
            <list>
                <value>math</value>
                <value>english</value>
            </list>
        </property>
    </bean>

    <bean id="helloService" class="com.example.sb2.IOC.xml.HelloService">
        <property name="student" ref="student" />
    </bean>

</beans>

```





静态工厂方法

```
package com.example.sb2.IOC.xml;

public abstract  class Animal {
    abstract  String getName();
}

```



```
package com.example.sb2.IOC.xml;

public class Cat extends Animal{
    @Override
    String getName() {
        return "cat";
    }
}


Dog类似
```



```java
package com.example.sb2.IOC.xml;

public class AnimalFactory {
    public static Animal getAnimal(String type) {
        if("dog".equals(type)){
            return new Dog();
        } else {
        	return new Cat();
        }
    }
}

```



修改helloService

```
package com.example.sb2.IOC.xml;

public class HelloService {
    private Student student;


    private Animal animal;


    public Animal getAnimal() {
        return animal;
    }

    public void setAnimal(Animal animal) {
        this.animal = animal;
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public String hello() {
        return student.toString();
    }

    public String hello2() {
        return animal.getName();
    }
}

```





```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="student" class="com.example.sb2.IOC.xml.Student">
        <constructor-arg index="0" value="zhangsan" />
        <constructor-arg index="1" value="20" />
<!--        <property name="name" value="zhangsan"/>-->
<!--        <property name="age" value="13"/>-->
        <property name="classList" >
            <list>
                <value>math</value>
                <value>english</value>
            </list>
        </property>
    </bean>

    <bean id="helloService" class="com.example.sb2.IOC.xml.HelloService">
        <property name="student" ref="student" />
        <property name="animal" ref="dog" />
    </bean>

    <bean id="dog" class="com.example.sb2.IOC.xml.AnimalFactory" factory-method="getAnimal">
        <constructor-arg value="dog" />
    </bean>

    <bean id="cat" class="com.example.sb2.IOC.xml.AnimalFactory" factory-method="getAnimal">
        <constructor-arg value="cat" />
    </bean>

</beans>

```



实例工厂方法

改造AnimalFactory

```java
package com.example.sb2.IOC.xml;

public class AnimalFactory {
    public  Animal getAnimal(String type) {
        if("dog".equals(type)){
            return new Dog();
        } else {
            return new Cat();
        }
    }
}

```



改造xml文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="student" class="com.example.sb2.IOC.xml.Student">
        <constructor-arg index="0" value="zhangsan" />
        <constructor-arg index="1" value="20" />
<!--        <property name="name" value="zhangsan"/>-->
<!--        <property name="age" value="13"/>-->
        <property name="classList" >
            <list>
                <value>math</value>
                <value>english</value>
            </list>
        </property>
    </bean>

    <bean id="helloService" class="com.example.sb2.IOC.xml.HelloService">
        <property name="student" ref="student" />
        <property name="animal" ref="dog" />
    </bean>

    <bean name="animalFactory" class="com.example.sb2.IOC.xml.AnimalFactory"/>


    <bean id="dog" class="com.example.sb2.IOC.xml.AnimalFactory" factory-bean="animalFactory" factory-method="getAnimal">
        <constructor-arg value="dog" />
    </bean>

    <bean id="cat" class="com.example.sb2.IOC.xml.AnimalFactory" factory-bean="animalFactory"  factory-method="getAnimal">
        <constructor-arg value="cat" />
    </bean>

</beans>

```



优点：

* 低耦合
* 对象关系比较清晰 通过xml 知道哪些类有依赖关系
* 集中管理

缺点：

* 配置繁琐

* 开发效率低

* 文件解析耗时

  

  



## 注解方式配置bean

* @Component
* 配置类中使用@Bean
* 实现FactoryBean
* 实现BeanDefinitonRegistryPostProcessor
* 实现ImportBeanDefinitionRegistry



### @Component

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="student" class="com.example.sb2.IOC.xml.Student">
        <constructor-arg index="0" value="zhangsan" />
        <constructor-arg index="1" value="20" />
<!--        <property name="name" value="zhangsan"/>-->
<!--        <property name="age" value="13"/>-->
        <property name="classList" >
            <list>
                <value>math</value>
                <value>english</value>
            </list>
        </property>
    </bean>

<!--    <bean id="helloService" class="com.example.sb2.IOC.xml.HelloService">-->
<!--        <property name="student" ref="student" />-->
<!--        <property name="animal" ref="dog" />-->
<!--    </bean>-->

    <bean name="animalFactory" class="com.example.sb2.IOC.xml.AnimalFactory"/>


    <bean id="dog" class="com.example.sb2.IOC.xml.AnimalFactory" factory-bean="animalFactory" factory-method="getAnimal">
        <constructor-arg value="dog" />
    </bean>

    <bean id="cat" class="com.example.sb2.IOC.xml.AnimalFactory" factory-bean="animalFactory"  factory-method="getAnimal">
        <constructor-arg value="cat" />
    </bean>

</beans>

```

改造helloService

```java
package com.example.sb2.IOC.xml;


import org.springframework.stereotype.Component;

@Component
public class HelloService {
    private Student student;


    private Animal animal;


    public Animal getAnimal() {
        return animal;
    }

    public void setAnimal(Animal animal) {
        this.animal = animal;
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public String hello() {
//        return student.toString();
        return "hello";
    }

    public String hello2() {
        return animal.getName();
    }
}

```

改造测试类



```java
package com.example.sb2;

import com.example.sb2.IOC.xml.HelloService;
import com.example.sb2.event.WeatherRunListener;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.context.web.WebAppConfiguration;

@RunWith(SpringRunner.class)
@SpringBootTest
@WebAppConfiguration
//@ContextConfiguration(locations = "classpath:ioc/demo.xml")
public class Sb2ApplicationTests {

	@Autowired
	private HelloService helloService;


	@Test
	public void testHello() {
		System.out.println(helloService.hello());
//		System.out.println(helloService.hello2());
	}



//	@Autowired
//	private WeatherRunListener weatherRunListener;

//
//	@Before
//	public void init() {
//		System.out.println("开始测试-----------------");
//	}
//
//	@After
//	public void after() {
//		System.out.println("测试结束-----------------");
//	}
//
//
//	@Test
//	public void testEvent() {
//		weatherRunListener.rain();
//		weatherRunListener.snow();
//	}


}

```

### 在配置类中注入bean

```java
package com.example.sb2.IOC.ann;


import com.example.sb2.IOC.xml.Animal;
import com.example.sb2.IOC.xml.Dog;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class BeanConfig {

    @Bean("dog")
    Animal getDog() {
        return new Dog();
    }
}

```



```
package com.example.sb2.IOC.xml;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class HelloService {
    private Student student;


    @Autowired
    private Animal animal;




    public Animal getAnimal() {
        return animal;
    }

    public void setAnimal(Animal animal) {
        this.animal = animal;
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public String hello() {
//        return student.toString();
        return "hello";
    }

    public String hello2() {
        return animal.getName();
    }
}

```



```
package com.example.sb2;

import com.example.sb2.IOC.xml.HelloService;
import com.example.sb2.event.WeatherRunListener;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.context.web.WebAppConfiguration;

@RunWith(SpringRunner.class)
@SpringBootTest
@WebAppConfiguration
//@ContextConfiguration(locations = "classpath:ioc/demo.xml")
public class Sb2ApplicationTests {

	@Autowired
	private HelloService helloService;


	@Test
	public void testHello() {
		System.out.println(helloService.hello());
		System.out.println(helloService.hello2());
	}



//	@Autowired
//	private WeatherRunListener weatherRunListener;

//
//	@Before
//	public void init() {
//		System.out.println("开始测试-----------------");
//	}
//
//	@After
//	public void after() {
//		System.out.println("测试结束-----------------");
//	}
//
//
//	@Test
//	public void testEvent() {
//		weatherRunListener.rain();
//		weatherRunListener.snow();
//	}


}

```



### 实现FactoryBean

```
package com.example.sb2.IOC.ann;

import com.example.sb2.IOC.xml.Animal;
import com.example.sb2.IOC.xml.Cat;
import org.springframework.beans.factory.FactoryBean;
import org.springframework.stereotype.Component;

@Component("mycat")
public class MyCat implements FactoryBean<Animal> {
    @Override
    public Animal getObject() throws Exception {
        return new Cat();
    }

    @Override
    public Class<?> getObjectType() {
        return Animal.class;
    }
}

```





```
package com.example.sb2.IOC.xml;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class HelloService {
    private Student student;


    @Autowired
    @Qualifier("mycat")
    private Animal animal;




    public Animal getAnimal() {
        return animal;
    }

    public void setAnimal(Animal animal) {
        this.animal = animal;
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public String hello() {
//        return student.toString();
        return "hello";
    }

    public String hello2() {
        return animal.getName();
    }
}

```



### 实现BeanDefinitonRegistryPostProcessor





```
package com.example.sb2.IOC.xml;

public class Monkey extends Animal{
    @Override
    String getName() {
        return "monkey";
    }
}

```



```java
package com.example.sb2.IOC.ann;

import com.example.sb2.IOC.xml.Monkey;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.stereotype.Component;

@Component
public class MyBeanRegister implements BeanDefinitionRegistryPostProcessor {
    @Override
    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry beanDefinitionRegistry) throws BeansException {
        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition();
        rootBeanDefinition.setBeanClass(Monkey.class);
        beanDefinitionRegistry.registerBeanDefinition("monkey", rootBeanDefinition);
    }

    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory configurableListableBeanFactory) throws BeansException {

    }
}

```





```
package com.example.sb2.IOC.xml;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class HelloService {
    private Student student;


    @Autowired
    @Qualifier("monkey")
    private Animal animal;




    public Animal getAnimal() {
        return animal;
    }

    public void setAnimal(Animal animal) {
        this.animal = animal;
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public String hello() {
//        return student.toString();
        return "hello";
    }

    public String hello2() {
        return animal.getName();
    }
}

```









### 实现ImportBeanDefinitionRegistry



```JAVA
package com.example.sb2.IOC.xml;

public class Bird extends Animal{
    @Override
    String getName() {
        return "bird";
    }
}

```





```
package com.example.sb2.IOC.ann;

import com.example.sb2.IOC.xml.Bird;
import com.example.sb2.IOC.xml.Monkey;
import org.springframework.beans.factory.support.BeanDefinitionRegistry;
import org.springframework.beans.factory.support.RootBeanDefinition;
import org.springframework.context.annotation.ImportBeanDefinitionRegistrar;
import org.springframework.core.type.AnnotationMetadata;

public class MyBeanImport implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        RootBeanDefinition rootBeanDefinition = new RootBeanDefinition();
        rootBeanDefinition.setBeanClass(Bird.class);
        registry.registerBeanDefinition("bird", rootBeanDefinition);
    }
}

```





```java
package com.example.sb2.IOC.xml;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
public class HelloService {
    private Student student;


    @Autowired
    @Qualifier("bird")
    private Animal animal;
a



    public Animal getAnimal() {
        return animal;
    }

    public void setAnimal(Animal animal) {
        this.animal = animal;
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }

    public String hello() {
//        return student.toString();
        return "hello";
    }

    public String hello2() {
        return animal.getName();
    }
}

```



```java
package com.example.sb2;

import com.example.sb2.IOC.ann.MyBeanImport;
import com.example.sb2.IOC.xml.HelloService;
import com.example.sb2.event.WeatherRunListener;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.ImportResource;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.test.context.web.WebAppConfiguration;

@RunWith(SpringRunner.class)
@SpringBootTest
@WebAppConfiguration
@Import(MyBeanImport.class)
//@ContextConfiguration(locations = "classpath:ioc/demo.xml")
public class Sb2ApplicationTests {

	@Autowired
	private HelloService helloService;


	@Test
	public void testHello() {
		System.out.println(helloService.hello());
		System.out.println(helloService.hello2());
	}



//	@Autowired
//	private WeatherRunListener weatherRunListener;

//
//	@Before
//	public void init() {
//		System.out.println("开始测试-----------------");
//	}
//
//	@After
//	public void after() {
//		System.out.println("测试结束-----------------");
//	}
//
//
//	@Test
//	public void testEvent() {
//		weatherRunListener.rain();
//		weatherRunListener.snow();
//	}


}

```



优点：

* 使用简单
* 开发效率高
* 高内聚

缺点

* 配置分散
* 对象关系不清晰
* 配置修改需要重新编译工程





# Banner解析

# 启动加载器解析

# 异常报告器解析

# 配置类解析

# Servlet容器启动解析

# Sb starter 解析

# Mybatis starter解析

# Webflux解析

# 日志系统解析

