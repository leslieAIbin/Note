---
typora-root-url: /images
---

# 多线程和并发（FULL XD+KS）



# 什么是并发编程

**进程是资源分配的最小单位，线程是CPU调度的最小单位**



​        并发历史:

​            早期计算机--从头到尾执行一个程序，资源浪费

​            操作系统出现--计算机能运行多个程序，不同的程序在不同的单独的进程中运行

​            一个进程，有多个线程

​                提高资源的利用率，公平



​        串行与并行的区别:

​            串行：洗茶具、打水、烧水、等水开、冲茶

​            并行：打水、烧水同时洗茶具、水开、冲茶



​            好处：可以缩短整个流程的时间



​        并发编程目的：

​            摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。这一定律揭示了信息技术进步的速度。

​            让程序充分利用计算机资源

​            加快程序响应速度（耗时任务、web服务器）

​            简化异步事件的处理



​        什么时候适合使用并发编程:

​            任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量计算的情况

​            任务执行时间过长，可以划分为分工明确的子任务：比如分段下载

​            任务间断性执行：日志打印

​            任务本身需要协作执行：比如生产者消费者问题



# 并发编程的挑战之频繁的上下文切换

​        cpu为线程分配时间片，时间片非常短（毫秒级别），cpu不停的切换线程执行，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这   个任务的状态，让我们感觉是多个程序同时运行的

​        上下文的频繁切换，会带来一定的性能开销 并发里面不是开的越多，就越高效

##         如何减少上下文切换的开销？

       * 无锁并发编程

​                无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一

​                些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据

        * CAS

​            Java的Atomic包使用CAS算法来更新数据，而不需要加锁。底层有一个原子性的操作帮我们去实现

      *  使用最少线程

​                避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这

​                样会造成大量线程都处于等待状态。

* 协程

​                在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。--GO 

# 并发编程的挑战之死锁

两人锁住，不放开

```java
package com.dutlzn.juc;

// 死锁

public class DeadLockDemo {
    private static final Object objectA = new Object();
    private static final Object objectB = new Object();

    public static void main(String[] args) {


        new Thread(() -> {
            System.out.println("A come in");
            synchronized (objectA) {

                // 增加线程休眠，就会有死锁发生
                try {
                    Thread.sleep(50L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (objectB) {
                    System.out.println("A 抓住了 B 的头发");
                }
            }
        }).start();


        new Thread(() -> {
            System.out.println("B come in");
            synchronized (objectB) {
                synchronized (objectA){
                    System.out.println("B 抓住了 A 的头发");
                }
            }
        }).start();


//        错误效果不明显， Thread.sleep 可以放大错误
//        new Thread(() -> {
//            System.out.println("A come in");
//            synchronized (objectA) {
//                synchronized (objectB) {
//                    System.out.println("A 抓住了 B 的头发");
//                }
//            }
//        }).start();
//
//
//        new Thread(() -> {
//            System.out.println("B come in");
//            synchronized (objectB) {
//                synchronized (objectA){
//                    System.out.println("B 抓住了 A 的头发");
//                }
//            }
//        }).start();
    }
}

```



在cmd中输入jps ，发现有这个pid卡死

jstack pid可以看这个线程的堆栈

jconsole 双击死锁的线程， 线程 -> 检测死锁

# 并发编程的挑战之线程安全



不是预期结果

```java
package com.dutlzn.juc;

// 线程不安全例子
public class UnsafeDemo {
    private static int num = 0;

    static void inCreate() {
        num++;
    }



    public static void main(String[] args) {
        System.out.println("unsafe test");
//        inCreate();
//        System.out.println(num);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int i1 = 0; i1 < 100; i1++) {
                    inCreate();
                }
            }).start();
        }

//        try {
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

        
        
        System.out.println(num);
    }
}

```

可能线程没被调用，main已经结束了 所以num 不是 1000

```java
package com.dutlzn.juc;

import java.util.concurrent.CountDownLatch;

// 线程不安全例子
public class UnsafeDemo {
    private static int num = 0;
    private static CountDownLatch countDownLatch = new CountDownLatch(10);

    static void inCreate() {
        num++;
    }



    public static void main(String[] args) {
        System.out.println("unsafe test");
//        inCreate();
//        System.out.println(num);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int i1 = 0; i1 < 100; i1++) {
                    inCreate();
                }

                //每个线程执行完成之后，调用countdownLatch
                countDownLatch.countDown();
            }).start();

        }

//        try {
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

//        System.out.println(num);

        while(true){
            if(countDownLatch.getCount() == 0){
                System.out.println(num);
                break;
            }
        }
    }

}

```



这个就到1000了

```java
package com.dutlzn.juc;

import java.util.concurrent.CountDownLatch;

// 线程不安全例子
public class UnsafeDemo {
    private static int num = 0;
    private static CountDownLatch countDownLatch = new CountDownLatch(10);

    static void inCreate() {
        num++;
    }



    public static void main(String[] args) {
        System.out.println("unsafe test");
//        inCreate();
//        System.out.println(num);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int i1 = 0; i1 < 100; i1++) {
                    inCreate();

                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                //每个线程执行完成之后，调用countdownLatch
                countDownLatch.countDown();
            }).start();

        }

//        try {
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

//        System.out.println(num);

        while(true){
            if(countDownLatch.getCount() == 0){
                System.out.println(num);
                break;
            }
        }
    }

}

```

这个又不行了 又拉了



没有进行同步操作



![](/1.png)



# 并发编程的挑战之资源限制

https://www.cnblogs.com/sun-rain/p/5735226.html



​        硬件资源

​            服务器： 1m

​            本机：2m 带宽20m 下载速度2m/s



​            带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。



​        软件资源

​            数据库连接 500个连接  1000个线程查询  并不会因此而加快

​            socket





# 进程与线程的区别

​        

​        **进程：是系统进行分配和管理资源的基本单位**



​        **线程：进程的一个执行单元，是进程内调度的实体、是CPU调度和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程,线程是程序执行的最小单位。**    



​        一个程序至少一个进程，一个进程至少一个线程。



​        进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。

​        而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。

​        **线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。**

​        如何处理好同步与互斥是编写多线程程序的难点。

​        多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，

​        而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以可能一个线程 出现问题，进而导致整个程序出现问题



# 线程的状态及其相互转换

1. ​        初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. ​        运行(RUNNABLE):处于可运行状态的线程正在JVM中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。
3. ​        阻塞(BLOCKED)：线程阻塞于synchronized锁，等待获取synchronized锁的状态。
4. ​        等待(WAITING)：Object.wait()、join()、 LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. ​        超时等待(TIME_WAITING)：Object.wait(long)、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil，该状态不同于WAITING，
6. ​        它可以在指定的时间内自行返回。
7. ​        终止(TERMINATED)：表示该线程已经执行完毕。



Runnable

```java
        // Runnable
//        Thread thread = new Thread(
//                ()->{
//                    try {
//                        System.in.read();
//                    } catch (IOException e) {
//                        e.printStackTrace();
//                    }
//                }
//        );
//        thread.start();
```



block

```java
// Blocked
        Object obj = new Object();
        Thread thread0 = new Thread(
                ()->{
                    synchronized (obj) {
                        try {
                            Thread.sleep(1000_000_000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                    }
                }
        );
        thread0.start();

        // 主线程延时
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        Thread thread2 = new Thread(
                () -> {
                    synchronized (obj){

                    }
                }
        );
        thread2.start();
```



waiting

```java
        // wait
        Object obj = new Object();

        Thread thread3 = new Thread(
                ()->{
                    synchronized (obj){
                        try {
                            obj.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
        );
        thread3.start();
```





![](/2.png)



#    创建线程的方式

​        1.继承Thread，并重写父类的run方法

```java

package com.dutlzn.juc.Thread;

public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName("线程0");
        myThread.start();
    }
}

```



​        2.实现Runable接口，并实现run方法

```java
package com.dutlzn.juc.Thread;

public class MyRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.setName("线程1");
        thread.start();
    }
}

```



​        实际开发中，选第2种：java只允许单继承

​        增加程序的健壮性，代码可以共享，代码跟数据独立



​        1.使用匿名内部类

```java
package com.dutlzn.juc.Thread;

// 匿名内部类
public class MyThread2 {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        });

        thread.setName("线程3");

        thread.start();
    }
}

```



​        2.Lambda表达式

```java
package com.dutlzn.juc.Thread;

public class Lambda {
    public static void main(String[] args) {
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName());
        }).start();
    }
}

```



​        3.线程池

```java
package com.dutlzn.juc.Thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPool {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        executorService.execute( ()-> {
            System.out.println(Thread.currentThread().getName());
        });

    }
}

```





# 线程的挂起跟恢复

## Thread.sleep 和 Object.wait的区别

https://www.cnblogs.com/ylxn/p/10395315.html

##    什么是挂起线程？

​            线程的挂起操作实质上就是使线程进入“非可执行”状态下，**在这个状态下CPU不会分给线程时间片**，进入这个状态可以用来暂停一个线程的运行。

​            在线程挂起后，可以通过重新唤醒线程来使之恢复运行



##       为什么要挂起线程？

​            cpu分配的时间片非常短、同时也非常珍贵。避免资源的浪费。



##         如何挂起线程？

​            被废弃的方法

​                thread.suspend() 该方法不会释放线程所占用的资源。如果使用该方法将某个线程挂起，则可能会使其他等待资源的线程死锁

​                thread.resume() 方法本身并无问题，但是不能独立于suspend()方法存在

```java
package com.dutlzn.juc.Hang;

// 线程挂起操作测试
public class SuspendDemo implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() +
                "\t执行run方法准备调用Suspend方法");

        // 线程挂起
        Thread.currentThread().suspend();

        System.out.println(Thread.currentThread().getName() +
                "\t执行run方法，调用Suspend方法结束");
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new SuspendDemo());

        thread.start();

        // 休眠一下主线程，让效果更加明显
        try {
            Thread.sleep(3000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 线程唤醒
        thread.resume();



    }
}

```



日常使用还是不要用了，不会释放锁，有可能引发死锁问题

以下代码效果正常

```java
package com.dutlzn.juc.Hang;

/**
 * suspend 死锁问题
 */
public class DeadDemo implements Runnable{

    private static Object object = new Object();

    @Override
    public void run() {
        // 持有资源
        synchronized (object){
            System.out.println(Thread.currentThread().getName() + "占用资源");
            Thread.currentThread().suspend();
        }

        System.out.println(Thread.currentThread().getName() + "释放资源");
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(new DeadDemo(), " 对比线程");
        thread1.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread1.resume();


        Thread thread2 = new Thread(new DeadDemo(), "死锁线程");

        thread2.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        thread2.resume();
    }
}

```

改一下效果不正常

```java
package com.dutlzn.juc.Hang;

/**
 * suspend 死锁问题
 */
public class DeadDemo implements Runnable{

    private static Object object = new Object();

    @Override
    public void run() {
        // 持有资源
        synchronized (object){
            System.out.println(Thread.currentThread().getName() + "占用资源");
            Thread.currentThread().suspend();
        }

        System.out.println(Thread.currentThread().getName() + "释放资源");
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(new DeadDemo(), " 对比线程");
        thread1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread1.resume();


        Thread thread2 = new Thread(new DeadDemo(), "死锁线程");

        thread2.start();
//        try {
//            Thread.sleep(3000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

        thread2.resume();
    }
}

```



​            可以使用的方法

​                wait() 暂停执行、放弃已经获得的锁、进入等待状态

​                notify() 随机唤醒一个在等待锁的线程

​                notifyAll() 唤醒所有在等待锁的线程，自行抢占cpu资源

```java
package com.dutlzn.juc.Hang;

public class WaitDemo implements Runnable{

    private static Object object = new Object();
    private static Object waitObj = new Object();

    @Override
    public void run() {
        // 持有资源
        synchronized (waitObj){
            System.out.println(Thread.currentThread().getName() + "占用资源");
            try {
                waitObj.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }


        System.out.println(Thread.currentThread().getName() + "释放资源");
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(new WaitDemo(), " 对比线程");
        thread1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (waitObj) {
            waitObj.notify();
        }

        
    }
}

```





##         什么时候适合使用挂起线程？

​            我等的船还不来(等待某些未就绪的资源)，我等的人还不明白。直到notify方法被调用

# 线程的中断操作

   stop() 废弃方法，开发中不要使用。因为一调用，线程就立刻停止，此时有可能引发相应的线程安全性问题

​        Thread.interrupt方法

​        自行定义一个标志，用来判断是否继续执行

stop示例代码

```java
package com.dutlzn.juc.Interrupt;

public class Demo implements Runnable{
    private static int index = 0;

    @Override
    public void run() {
        while(true){
            index++;
            System.out.println(index + "\t" +Thread.currentThread().getName());

            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    public static void main(String[] args) {
        Thread thread = new Thread(new Demo());
        thread.start();

        // 主线程睡眠
        try {
            Thread.sleep(4*1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 废弃方法,不推荐使用
        thread.stop();

    }
}

```

线程不安全，示例

```java
package com.dutlzn.juc.Interrupt;

public class UnsafeWithStop implements Runnable{
    private int i = 0;
    private int j = 0;

    @Override
    public void run() {
        i++;

        // 该线程还在休眠，主线程已经结束了
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        j++;
    }

    public void printf(){
        System.out.println("val of i: "+i +"\t val of j: "+j);
    }

    public static void main(String[] args) {
        UnsafeWithStop unsafeWithStop = new UnsafeWithStop();
        Thread thread = new Thread(unsafeWithStop);
        thread.start();

        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        thread.stop();
        unsafeWithStop.printf();
    }
}

```

利用Interrupt

```java
package com.dutlzn.juc.Interrupt;

public class InterruptDemo implements Runnable {
    @Override
    public void run() {
        while(!Thread.currentThread().isInterrupted()){
            System.out.println(Thread.currentThread().getName());

        }

    }

    public static void main(String[] args) {
        Thread thread = new Thread(new InterruptDemo());
        thread.start();

        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        thread.interrupt();


    }
}

```

定义标志位

```java
package com.dutlzn.juc.Interrupt;


public class MyInterruptDemo implements Runnable{

    public static volatile boolean FLAG = true;

    @Override
    public void run() {
        while(FLAG){
            System.out.println(Thread.currentThread().getName());
        }
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyInterruptDemo());
        thread.start();


        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        FLAG = false;


    }
}

```

# 线程的优先级

**线程的优先级告诉程序该线程的重要程度有多大**。如果有大量线程都被堵塞，都在等候运行，程序会尽可能地先运行优先级的那个线程。  但是，这并不表示优先级较低的线程不会运行。若线程的优先级较低，只不过表示它被准许运行的**机会小**一些而已。



​        线程的优先级设置可以为1-10的任一数值，Thread类中定义了三个线程优先级，分别是：

​        MIN_PRIORITY（1）、NORM_PRIORITY（5）、MAX_PRIORITY（10），一般情况下推荐使用这几个常量，不要自行设置数值。



​        不同平台，对线程的优先级的支持不同。  编程的时候，不要过度依赖线程优先级，如果你的程序运行是否正确取决于你设置的优先级是否按所设置的优先级运行，那这样的程序不正确



​        任务：

​            快速处理：设置高的优先级

​            慢慢处理：设置低的优先级

示例代码:

```java
package com.dutlzn.juc.priority;

/**
 * 线程优先级 测试
 */
public class PriorityDemo {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            while (true){
                System.out.println(Thread.currentThread().getName());
//                try {
//                    Thread.sleep(1000L);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
            }
        }, "线程1");

        Thread thread2 = new Thread(() -> {
            while(true){
                System.out.println(Thread.currentThread().getName());
//                try {
//                    Thread.sleep(1000L);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
            }
        }, "线程2");


        thread1.setPriority(Thread.MIN_PRIORITY);
        thread2.setPriority(Thread.MAX_PRIORITY);

        thread1.start();
        thread2.start();
    }
}

```



# 守护线程

​        线程分类

​            用户线程、守护线程

用户线程，执行完了，才停止，main停止了，但是自定义的线程没有停止，就会继续跑下去



​            **守护线程：任何一个守护线程都是整个程序中所有用户线程的守护者，只要有活着的用户线程，守护线程就活着。当JVM实例中最后一个非守护线程结束时，也随JVM一起退出**



​            守护线程的用处：**jvm垃圾清理线程**



​        建议： 尽量少使用守护线程，因其不可控

​              不要在守护线程里去进行读写操作、执行计算逻辑

```java
package com.dutlzn.juc.guard;

/**
 * 守护线程 测试
 */
public class DemonThreadDemo implements Runnable{
    @Override
    public void run() {
        while(true){
            System.out.println(Thread.currentThread().getName());
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new DemonThreadDemo());
        thread.setDaemon(true);
        thread.start();
        // 主线程休眠两秒
        Thread.sleep(2000L);

    }
}

```

主线程结束了，守护线程也退出了

----



#  什么是线程安全性？

​        当多个线程访问某个类,不管运行时环境采用何种调度方式或者这些线程如何交替执行,并且在主调代码中不需要任何额外的同步或协同,这个类都能表现出正确的行为,那么就称这个类为线程安全的。----《并发编程实战》



​        什么是线程不安全？

​            **多线程并发访问时，得不到正确的结果。** 

# 从字节码角度剖析线程不安全操作

新建文件夹unsafe

从字节码角度剖析线程不安全操作

​       javac -encoding UTF-8 UnsafeThread.java 编译成.class

​       javap -c UnsafeThread.class 进行反编译，得到相应的字节码指令



​       0: getstatic     #2               获取指定类的静态域，并将其押入栈顶

​       3: iconst_1                       将int型1押入栈顶

​       4: iadd                           将栈顶两个int型相加，将结果押入栈顶

​       5: putstatic     #2               为指定类静态域赋值

​       8: return



​       例子中，产生线程不安全问题的原因：

​            **num++ 不是原子性操作**，被拆分成好几个步骤，在多线程并发执行的情况下，因为cpu调度，多线程快递切换，有可能两个同一时刻都读取了同一个num值，之后对它进行+1操作，导致线程安全性。

# 原子性操作

##         什么是原子性操作

​            一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

​            A想要从自己的帐户中转1000块钱到B的帐户里。那个从A开始转帐，到转帐结束的这一个过程，称之为一个事务。在这个事务里，要做如下操作：

​            \1. 从A的帐户中减去1000块钱。如果A的帐户原来有3000块钱，现在就变成2000块钱了。

​            \2. 在B的帐户里加1000块钱。如果B的帐户如果原来有2000块钱，现在则变成3000块钱了。

​            如果在A的帐户已经减去了1000块钱的时候，忽然发生了意外，比如停电什么的，导致转帐事务意外终止了，而此时B的帐户里还没有增加1000块钱。

​            那么，我们称这个操作失败了，要进行回滚。回滚就是回到事务开始之前的状态，也就是回到A的帐户还没减1000块的状态，B的帐户的原来的状态。

​            此时A的帐户仍然有3000块，B的帐户仍然有2000块。

​            **通俗点讲：操作要成功一起成功、要失败大家一起失败**



##         如何把非原子性操作变成原子性

​            **volatile关键字仅仅保证可见性，并不保证原子性**

​            **synchronize关键字，使得操作具有原子性**



## 深入理解Volatile

参考

https://www.cnblogs.com/zhengbin/p/5654805.html

重排序





这样写就可以让操作具有原子性

```java
package com.dutlzn.juc.Unsafe;

import java.util.concurrent.CountDownLatch;

// 线程不安全例子
public class UnsafeDemo {
    private static  int num = 0;
    private static CountDownLatch countDownLatch = new CountDownLatch(10);

    static synchronized void inCreate() {
        num++;
    }



    public static void main(String[] args) {
        System.out.println("unsafe test");
//        inCreate();
//        System.out.println(num);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int i1 = 0; i1 < 100; i1++) {
                    inCreate();

                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                //每个线程执行完成之后，调用countdownLatch
                countDownLatch.countDown();
            }).start();

        }

//        try {
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

//        System.out.println(num);

        while(true){
            if(countDownLatch.getCount() == 0){
                System.out.println(num);
                break;
            }
        }
    }

}

```



# 深入理解synchronized

## 内置锁 

​            每个java对象都可以用做一个实现同步的锁，这些锁称为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。



## 互斥锁

​            内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。

## 如何用

​        修饰普通方法：锁住对象的实例 ， 是分开的

```java
package com.dutlzn.juc.safe;

public class SynDemo {
    public synchronized void out() {
        System.out.println(Thread.currentThread().getName());
        try {
            Thread.sleep(5000l);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

//    public synchronized static void staticOut() {
//
//    }
//
//
//    public void myOut() {
//        synchronized (){
//
//        }
//    }

    public static void main(String[] args) {
        SynDemo synDemo1 = new SynDemo();
        SynDemo synDemo2 = new SynDemo();
        new Thread(()->{
            synDemo1.out();
        }).start();
        new Thread(()->{
            synDemo2.out();
        }).start();
    }
}

```

同时输出

​        修饰静态方法：锁住整个类

```java
package com.dutlzn.juc.safe;

public class SynDemo {
//    public synchronized void out() {
//        System.out.println(Thread.currentThread().getName());
//        try {
//            Thread.sleep(5000l);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//
//    }

    public synchronized static void staticOut() {
        System.out.println(Thread.currentThread().getName());

        try {
            Thread.sleep(5000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
//
//
//    public void myOut() {
//        synchronized (){
//
//        }
//    }

    public static void main(String[] args) {
        SynDemo synDemo1 = new SynDemo();
        SynDemo synDemo2 = new SynDemo();
        new Thread(()->{
            staticOut();
        }).start();
        new Thread(()->{
            staticOut();
        }).start();
    }
}

```

先后顺序 其他方面一直在等待当前线程的锁





​        修饰代码块： 锁住一个对象 synchronized (lock) 即synchronized后面括号里的内容

```java
package com.dutlzn.juc.safe;

public class SynDemo {
//    public synchronized void out() {
//        System.out.println(Thread.currentThread().getName());
//        try {
//            Thread.sleep(5000l);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//
//    }


//
//    public synchronized static void staticOut() {
//        System.out.println(Thread.currentThread().getName());
//
//        try {
//            Thread.sleep(5000L);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//
//    }
//


    private static Object lock = new Object();
    public void myOut() {
        synchronized (lock){
            System.out.println(Thread.currentThread().getName());
            try {
                Thread.sleep(5000l);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }

    public static void main(String[] args) {
        SynDemo synDemo1 = new SynDemo();
        SynDemo synDemo2 = new SynDemo();
        new Thread(()->{
            synDemo1.myOut();
        }).start();
        new Thread(()->{
            synDemo2.myOut();
        }).start();
    }
}

```

先后顺序

# volatile关键字及其使用场景

## volatile关键字

​        **能且仅能修饰变量**

​        保证该变量的可见性，volatile关键字**仅仅保证可见性，并不保证原子性**

​        **禁止指令重排序**



​        A、B两个线程同时读取volatile关键字修饰的对象

​        A读取之后，修改了变量的值

​        修改后的值，对B线程来说，是可见



volatile不使用锁



##  使用场景

​            1：作为线程开关

```java
package com.dutlzn.juc.safe;

public class VolatileDemo implements Runnable{
    private static volatile boolean flag = true;

    @Override
    public void run() {
        while(flag){
            System.out.println(Thread.currentThread().getName());
        }
    }
}

```



​            2：单例，修饰对象实例，禁止指令重排序



# 单例和线程安全

##         饿汉式--本身线程安全

​            在类加载的时候，就已经进行实例化，无论之后用不用到。如果该类比较占内存，之后又没用到，就白白浪费了资源。

```java
package com.dutlzn.juc.safe;


/**
 * 饿汉式单例模式
 * 在类加载的时候，就已经有实例化了
 *
 */
public class HungerSingleton {
    private static HungerSingleton ourInstance = new HungerSingleton();

    public static HungerSingleton getInstance() {
        return ourInstance;
    }

    private HungerSingleton() {

    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(
                    () -> {
                        System.out.println(HungerSingleton.getInstance());
                    }
            ).start();
        }
    }
}

```



##         懒汉式 -- 最简单的写法是非线程安全的

​            在需要的时候再实例化



不加延时没问题

```java
package com.dutlzn.juc.safe;

/**
 * 懒汉式
 * 在需要的时候 实例化
 */
public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public static  LazySingleton getInstance() {
        if(lazySingleton == null){
            lazySingleton =  new LazySingleton();
        }

        return lazySingleton;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(LazySingleton.getInstance());
            }).start();
        }
    }
}

```



加了模拟实例化耗时就有问题了

```java
package com.dutlzn.juc.safe;

/**
 * 懒汉式
 * 在需要的时候 实例化
 */
public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public static  LazySingleton getInstance() {
        if(lazySingleton == null){
            try {
                Thread.sleep(100L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            lazySingleton =  new LazySingleton();
        }

        return lazySingleton;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(LazySingleton.getInstance());
            }).start();
        }
    }
}

```

加一个关键字就线程安全了

```java
package com.dutlzn.juc.safe;

/**
 * 懒汉式
 * 在需要的时候 实例化
 */
public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public synchronized  static  LazySingleton getInstance() {
        if(lazySingleton == null){
            try {
                Thread.sleep(100L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            lazySingleton =  new LazySingleton();
        }

        return lazySingleton;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(LazySingleton.getInstance());
            }).start();
        }
    }
}

```

这样做有点消耗性能

只要有一个线程实例化了，其他线程都可以去访问它

改成这样就ok了

```java
package com.dutlzn.juc.safe;

/**
 * 懒汉式
 * 在需要的时候 实例化
 */
public class LazySingleton {

    private static LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public  static  LazySingleton getInstance() {
        if(lazySingleton == null){
            try {
                Thread.sleep(100L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // 锁住

            synchronized (LazySingleton.class) {
                if(lazySingleton == null){
                    lazySingleton =  new LazySingleton();
                }
            }
        }

        return lazySingleton;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(LazySingleton.getInstance());
            }).start();
        }
    }
}

```



但是这段代码可能会有指令重排序问题

我们在实际开发中需要禁止指令重排序 如下所示 volatile可以禁止指令重排序

```java
package com.dutlzn.juc.safe;

/**
 * 懒汉式
 * 在需要的时候 实例化
 */
public class LazySingleton {

    private static volatile LazySingleton lazySingleton = null;

    private LazySingleton() {

    }

    public  static  LazySingleton getInstance() {
        if(lazySingleton == null){
            try {
                Thread.sleep(100L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            // 锁住

            synchronized (LazySingleton.class) {
                if(lazySingleton == null){
                    lazySingleton =  new LazySingleton();
                }
            }
        }

        return lazySingleton;
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                System.out.println(LazySingleton.getInstance());
            }).start();
        }
    }
}

```



# 如何避免线程安全性问题呢？

## 线程安全性问题成因

​            1：多线程环境

​            2：多个线程操作同一共享资源

​            3：对该共享资源进行了**非原子性**操作



## 如何避免

​            打破成因中三点任意一点

​                1：多线程环境--将多线程改单线程**（必要的代码，加锁访问）**

​                2：多个线程操作同一共享资源--不共享资源**（ThreadLocal、不共享、操作无状态化、不可变）**

​                3：对该共享资源进行了非原子性操作-- 将非原子性操作改成原子性操作**（加锁、使用JDK自带的原子性操作的类、JUC提供的相应的并发工具类）**



# 锁的分类

##         自旋锁：

线程状态及上下文切换消耗系统资源，当访问共享资源的时间短，频繁上下文切换不值得。jvm实现，使线程在没获得锁的时候，不被挂起，转而执行空循环，循环几次之后，如果还没能获得锁，则被挂起



##         阻塞锁：

阻塞锁改变了线程的运行状态，让线程进入阻塞状态进行等待，当获得相应的信号（唤醒或者时间）时，才可以进入线程的准备就绪状态，转为就绪状态的所有线程，通过竞争，进入运行状态



##         重入锁:

支持线程再次进入的锁,就跟我们有房间钥匙，可以多次进入房间类似



##         读写锁： 

两把锁，读锁跟写锁，写写互斥、读写互斥、读读共享



##         互斥锁：

 上厕所，进门之后就把门关了，不让其他人进来



##         悲观锁：

 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁



##         乐观锁：

每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。



##         公平锁：

大家都老老实实排队，对大家而言都很公平



##         非公平锁：

一部分人排着队，但是新来的可能插队



##         偏向锁：

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁



##         独占锁：

独占锁模式下，每次只能有一个线程能持有锁



##         共享锁：

允许多个线程同时获取锁，并发访问共享资源

# 深入理解Lock接口

## Lock的使用

```java
package com.dutlzn.juc.lock;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class UnsafeThread {
    private static int num = 0;

    private static CountDownLatch countDownLatch = new CountDownLatch(10);

    private static Lock lock = new ReentrantLock();

    /**
     * 每次调用对num进行++操作
     */
//
//    public  static void inCreate() {
//        // 非原子性操作
//        num++;
//    }
    public static void inCreate() {
        // 上锁
        lock.lock();
        // 非原子性操作
        num++;
        // 释放锁
        lock.unlock();
    }

    public static void test() {
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int i1 = 0; i1 < 100; i1++) {
                    inCreate();

                    // 线程适当休眠
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                //每个线程执行完成之后，调用countdownLatch
                countDownLatch.countDown();
            }).start();

        }

            while(true){
                if(countDownLatch.getCount() == 0){
                    System.out.println(num);
                    break;
                }
            }
        }
    }

```



##  lock与synchronized的区别

lock 性能上比synchronized好点

lock

​                获取锁与释放锁的过程，都需要程序员**手动的控制**

​                Lock用的是**乐观锁**方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**乐观锁实现的机制就 是CAS操作**

synchronized托管给jvm执行

​                原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。



## 实现了lock接口的锁

ctrl+alt+b

## 各个方法的简介

lock 上锁

lockInterruptibly 也是一个上锁的操作 允许在等待的时候，等待获取锁的时候，允许其他线程调用Thread.Interrupt方法

去中断等待，直接返回 不用等待获取锁，直接抛出异常  lock是不允许其他线程调用interrupt方法去中断

tryLock  尝试获得锁，佛系，能成功就成功，不成功就算了

tryLock 带时间尝试获得锁， 在指定时间内，尝试30s内去尝试

unlock 释放锁

newCondition()  wait notified 有点相似

# 实现属于自己的锁

​        实现lock接口

​        使用wait notify

```java
package com.dutlzn.juc.lock.mylock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {
    private boolean isHoldLock = false;

    /**
     * 同一个时刻能且仅能有一个线程获取到锁，
     * 其他线程，只能等待该线程释放锁之后才能获取锁
     */
    @Override
    public synchronized void lock() {
        if (isHoldLock) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        isHoldLock = true;
    }

    @Override
    public synchronized void unlock() {
        notify();
        isHoldLock = false;
    }



    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    @Override
    public boolean tryLock() {
        return false;
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return false;
    }



    @Override
    public Condition newCondition() {
        return null;
    }
}

```

可重入性？

```java
package com.dutlzn.juc.lock.mylock;

import java.util.concurrent.locks.Lock;

// 可重入测试
public class ReetryDemo {
    private Lock lock = new MyLock();

    public void methodA() {
        lock.lock();
        System.out.println("进入方法a");
        methodB();
        lock.unlock();
    }

    public void methodB() {
        lock.lock();
        System.out.println("进入方法b");
        lock.unlock();
    }

    public static void main(String[] args) {
        ReetryDemo reetryDemo = new ReetryDemo();
        reetryDemo.methodA();
    }


}

```

用jconsole检测死锁，并没有检查死锁

```java
package com.dutlzn.juc.lock.mylock;

import java.util.concurrent.locks.Lock;

// 可重入测试
public class ReetryDemo {
    private Lock lock = new MyLock();

    public void methodA() {
        lock.lock();
        System.out.println("进入方法a");
        methodB();
        lock.unlock();
    }

    public void methodB() {
        lock.lock();
        System.out.println("进入方法b");
        lock.unlock();
    }

    public static void main(String[] args) {
        ReetryDemo reetryDemo = new ReetryDemo();
        reetryDemo.methodA();
    }


}

```

以上代码是不能达到可重入的效果的 一直在waiting

修改一下代码就可以实现重入了

```java

package com.dutlzn.juc.lock.mylock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class MyLock implements Lock {
    // 当前有没有锁
    private boolean isHoldLock = false;

    // 上锁的线程
    private Thread holdLockThread = null;

    // 重入次数
    private int reentryCount = 0;

    /**
     * 同一个时刻能且仅能有一个线程获取到锁，
     * 其他线程，只能等待该线程释放锁之后才能获取锁
     */
    @Override
    public synchronized void lock() {
        if (isHoldLock && Thread.currentThread() != holdLockThread) {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        holdLockThread = Thread.currentThread();
        isHoldLock = true;
        reentryCount++;
    }

    @Override
    public synchronized void unlock() {

        // 判断当前线程是否是持有锁的线程，是，重入次数减去1，不是就是不做处理
        if(Thread.currentThread() == holdLockThread) {
            reentryCount--;
            if(reentryCount == 0){
                notify();
                isHoldLock = false;
            }
        }

    }



    @Override
    public void lockInterruptibly() throws InterruptedException {

    }

    @Override
    public boolean tryLock() {
        return false;
    }

    @Override
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {
        return false;
    }



    @Override
    public Condition newCondition() {
        return null;
    }
}

```



# AbstractQueuedSynchronizer浅析(AQS)



​        AbstractQueuedSynchronizer -- 为实现依赖于**先进先出** (FIFO) 等待队列的阻塞锁和相关同步器（信号量、事件，等等）提供一个框架。

​        此类的设计目标是成为依靠单个原子 int 值来表示状态的大多数同步器的一个有用基础。(上一节提到了三个变量)



​        子类必须定义更改此状态的受保护方法，并定义哪种状态对于此对象意味着被获取或被释放。

​        假定这些条件之后，此类中的其他方法就可以实现所有排队和阻塞机制。子类可以维护其他状态字段，但只是为了获得同步而只追踪使用 getState()、setState(int) 和 compareAndSetState(int, int) 方法来操作以原子方式更新的 int 值。

​        应该将子类定义为非公共内部帮助器类，可用它们来实现其封闭类的同步属性。类 AbstractQueuedSynchronizer 没有实现任何同步接口。而是定义了诸如 acquireInterruptibly(int) 之类的一些方法，在适当的时候可以通过具体的锁和相关同步器来调用它们，以实现其公共方法。



​        此类支持默认的独占 模式和共享 模式之一，或者二者都支持。处于独占模式下时，其他线程试图获取该锁将无法取得成功。在共享模式下，多个线程获取某个锁可能（但不是一定）会获得成功。此类并不“了解”这些不同，除了机械地意识到当在共享模式下成功获取某一锁时，下一个等待线程（如果存在）也必须确定自己是否可以成功获取该锁。处于不同模式下的等待线程可以共享相同的 FIFO 队列。通常，实现子类只支持其中一种模式，但两种模式都可以在（例如）ReadWriteLock 中发挥作用。只支持独占模式或者只支持共享模式的子类不必定义支持未使用模式的方法。



​        此类通过支持独占模式的子类定义了一个嵌套的 AbstractQueuedSynchronizer.ConditionObject 类，可以将这个类用作 Condition 实现。isHeldExclusively() 方法将报告同步对于当前线程是否是独占的；使用当前 getState() 值调用 release(int) 方法则可以完全释放此对象；如果给定保存的状态值，那么 acquire(int) 方法可以将此对象最终恢复为它以前获取的状态。没有别的 AbstractQueuedSynchronizer 方法创建这样的条件，因此，如果无法满足此约束，则不要使用它。AbstractQueuedSynchronizer.ConditionObject 的行为当然取决于其同步器实现的语义。



​        此类为内部队列提供了检查、检测和监视方法，还为 condition 对象提供了类似方法。可以根据需要使用用于其同步机制的 AbstractQueuedSynchronizer 将这些方法导出到类中。



​        此类的序列化只存储维护状态的基础原子整数，因此已序列化的对象拥有空的线程队列。需要可序列化的典型子类将定义一个 readObject 方法，该方法在反序列化时将此对象恢复到某个已知初始状态。

```java
	tryAcquire(int)
		tryRelease(int)
		tryAcquireShared(int)
		tryReleaseShared(int)
		isHeldExclusively()
			Acquire:
		     while (!tryAcquire(arg)) {
                 // 等待队列
			        enqueue thread if it is not already queued;
			        possibly block current thread;
			     }

			Release:
				   if ((arg))
				        unblock the first queued thread;
```

没有继承，会抛出异常

```java
 protected boolean tryAcquire(int arg) {
        throw new UnsupportedOperationException();
    }
```

# 深入剖析ReentrantLock源码之非公平锁的实现

##         如何阅读源码？

​            一段简单的代码

​            看构造

​            看类之间的关系，形成关系图

​            看使用到的方法，并逐步理解，边看代码边看注释

​            debug

## 源码分析

简单测试代码

```java
package com.dutlzn.juc.lock;

import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo {
    public static void main(String[] args) {
        ReentrantLock reentrantLock = new ReentrantLock();
        reentrantLock.lock();
        reentrantLock.unlock();
    }
}
```

翻译插件  选中需要翻译的句子，ctrl+shift+y就可以了

```java
 final void lock() {
            if (compareAndSetState(0, 1))
                // 0 ---> 1 成功获取到锁
                setExclusiveOwnerThread(Thread.currentThread());
            else
                // 锁已经被其他人所有了
                acquire(1);
        }
```



```java
   public final void acquire(int arg) {
       // 尝试获取 尝试入队列 都失败了，就终止了
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```



看的是非公平的实现 ctrl+alt+b

查看源码 返回上一级 ctrl + alt +方向键

```java
final boolean nonfairTryAcquire(int acquires) {
            final Thread current = Thread.currentThread();
            int c = getState(); // 状态 volatile
    	   // 当前没有线程获取到锁
            if (c == 0) {
                // cas
                if (compareAndSetState(0, acquires)) {
                    // 当前线程设置为持有锁的线程
                    setExclusiveOwnerThread(current);
                    return true;
                }
            }
    		// 当前线程是不是持有锁的线程 重入的状态
            else if (current == getExclusiveOwnerThread()) {
                //  相当于自己实现的时候，重入次数加了1
                int nextc = c + acquires;
                // 超过了int的最大值
                if (nextc < 0) // overflow
                    throw new Error("Maximum lock count exceeded");
                setState(nextc);
                return true;
            }
            return false;
        }
```



```JAVA
private Node addWaiter(Node mode) {
    // 双向链表
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }

```



# 深入剖析ReentrantLock源码之公平锁的实现  

##         公平锁与非公平锁的区别

​            公平锁：顾名思义--公平，大家老老实实排队

​            非公平锁：只要有机会，就先尝试抢占资源

​            公平锁与非公平锁其实有点像在公厕上厕所。公平锁遵守排队的规则，只要前面有人在排队，那么刚进来的就老老实实排队。而非公平锁就有点流氓，只要当前茅坑没人，它就占了那个茅坑，不管后面的人排了多久。



##         非公平锁的弊端

​            可能导致后面排队等待的线程等不到相应的cpu资源，从而引起线程饥饿

## 简单测试

```java
package com.dutlzn.juc.lock;

import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockDemo {
    public static void main(String[] args) {
        // 有参数就是公平锁实现方式  实际生产中应该使用公平锁
        ReentrantLock reentrantLock = new ReentrantLock(true);
        reentrantLock.lock();
        reentrantLock.unlock();
    }
}

```

# 掌控线程执行顺序之多线程debug（技能）









# 线程间的通信



# wait、notify、notifyAll



```java
package com.dutlzn.conmunication.demo1;

public class Demo {
    private static volatile boolean flag = false;

    public static void main(String[] args) throws InterruptedException {
        new Thread(() -> {
            while(!flag) {
                try {
                    // 休眠的时间是不可预估的。不够及时
                    Thread.sleep(1000L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("flag is false");
            }


            System.out.println("flag is true");
        }).start();

        Thread.sleep(1000L);

        new Thread(() -> {
            flag = true;
        }).start();

    }
}

```



- 何时使用 在多线程环境下，有时候一个线程的执行，依赖于另外一个线程的某种状态的改变，这个时候，我们就可以使用wait与notify或者notifyAll

  

- wait跟sleep的区别 wait会释放持有的锁，而sleep不会，sleep只是让线程在指定的时间内，不去抢占cpu的资源 

- 

- **注意点 wait notify必须放在同步代码块中, 且必须拥有当前对象的锁，即不能取得A对象的锁，而调用B对象的wait 哪个对象wait，就得调哪个对象的notify**

- notify跟notifyAll的区别

  nofity随机唤醒一个等待的线程 notifyAll唤醒所有在该对象上等待的线程

 





