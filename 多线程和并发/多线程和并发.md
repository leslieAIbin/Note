---
typora-root-url: /images
---

# 多线程和并发（FULL XD+KS）



# 什么是并发编程

**进程是资源分配的最小单位，线程是CPU调度的最小单位**



​        并发历史:

​            早期计算机--从头到尾执行一个程序，资源浪费

​            操作系统出现--计算机能运行多个程序，不同的程序在不同的单独的进程中运行

​            一个进程，有多个线程

​                提高资源的利用率，公平



​        串行与并行的区别:

​            串行：洗茶具、打水、烧水、等水开、冲茶

​            并行：打水、烧水同时洗茶具、水开、冲茶



​            好处：可以缩短整个流程的时间



​        并发编程目的：

​            摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。这一定律揭示了信息技术进步的速度。

​            让程序充分利用计算机资源

​            加快程序响应速度（耗时任务、web服务器）

​            简化异步事件的处理



​        什么时候适合使用并发编程:

​            任务会阻塞线程，导致之后的代码不能执行：比如一边从文件中读取，一边进行大量计算的情况

​            任务执行时间过长，可以划分为分工明确的子任务：比如分段下载

​            任务间断性执行：日志打印

​            任务本身需要协作执行：比如生产者消费者问题



# 并发编程的挑战之频繁的上下文切换

​        cpu为线程分配时间片，时间片非常短（毫秒级别），cpu不停的切换线程执行，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这   个任务的状态，让我们感觉是多个程序同时运行的

​        上下文的频繁切换，会带来一定的性能开销 并发里面不是开的越多，就越高效

##         如何减少上下文切换的开销？

       * 无锁并发编程

​                无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一

​                些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据

        * CAS

​            Java的Atomic包使用CAS算法来更新数据，而不需要加锁。底层有一个原子性的操作帮我们去实现

      *  使用最少线程

​                避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这

​                样会造成大量线程都处于等待状态。

* 协程

​                在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。--GO 

# 并发编程的挑战之死锁

两人锁住，不放开

```java
package com.dutlzn.juc;

// 死锁

public class DeadLockDemo {
    private static final Object objectA = new Object();
    private static final Object objectB = new Object();

    public static void main(String[] args) {


        new Thread(() -> {
            System.out.println("A come in");
            synchronized (objectA) {

                // 增加线程休眠，就会有死锁发生
                try {
                    Thread.sleep(50L);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (objectB) {
                    System.out.println("A 抓住了 B 的头发");
                }
            }
        }).start();


        new Thread(() -> {
            System.out.println("B come in");
            synchronized (objectB) {
                synchronized (objectA){
                    System.out.println("B 抓住了 A 的头发");
                }
            }
        }).start();


//        错误效果不明显， Thread.sleep 可以放大错误
//        new Thread(() -> {
//            System.out.println("A come in");
//            synchronized (objectA) {
//                synchronized (objectB) {
//                    System.out.println("A 抓住了 B 的头发");
//                }
//            }
//        }).start();
//
//
//        new Thread(() -> {
//            System.out.println("B come in");
//            synchronized (objectB) {
//                synchronized (objectA){
//                    System.out.println("B 抓住了 A 的头发");
//                }
//            }
//        }).start();
    }
}

```



在cmd中输入jps ，发现有这个pid卡死

jstack pid可以看这个线程的堆栈

jconsole 双击死锁的线程， 线程 -> 检测死锁

# 并发编程的挑战之线程安全



不是预期结果

```java
package com.dutlzn.juc;

// 线程不安全例子
public class UnsafeDemo {
    private static int num = 0;

    static void inCreate() {
        num++;
    }



    public static void main(String[] args) {
        System.out.println("unsafe test");
//        inCreate();
//        System.out.println(num);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int i1 = 0; i1 < 100; i1++) {
                    inCreate();
                }
            }).start();
        }

//        try {
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

        
        
        System.out.println(num);
    }
}

```

可能线程没被调用，main已经结束了 所以num 不是 1000

```java
package com.dutlzn.juc;

import java.util.concurrent.CountDownLatch;

// 线程不安全例子
public class UnsafeDemo {
    private static int num = 0;
    private static CountDownLatch countDownLatch = new CountDownLatch(10);

    static void inCreate() {
        num++;
    }



    public static void main(String[] args) {
        System.out.println("unsafe test");
//        inCreate();
//        System.out.println(num);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int i1 = 0; i1 < 100; i1++) {
                    inCreate();
                }

                //每个线程执行完成之后，调用countdownLatch
                countDownLatch.countDown();
            }).start();

        }

//        try {
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

//        System.out.println(num);

        while(true){
            if(countDownLatch.getCount() == 0){
                System.out.println(num);
                break;
            }
        }
    }

}

```



这个就到1000了

```java
package com.dutlzn.juc;

import java.util.concurrent.CountDownLatch;

// 线程不安全例子
public class UnsafeDemo {
    private static int num = 0;
    private static CountDownLatch countDownLatch = new CountDownLatch(10);

    static void inCreate() {
        num++;
    }



    public static void main(String[] args) {
        System.out.println("unsafe test");
//        inCreate();
//        System.out.println(num);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int i1 = 0; i1 < 100; i1++) {
                    inCreate();

                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                //每个线程执行完成之后，调用countdownLatch
                countDownLatch.countDown();
            }).start();

        }

//        try {
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

//        System.out.println(num);

        while(true){
            if(countDownLatch.getCount() == 0){
                System.out.println(num);
                break;
            }
        }
    }

}

```

这个又不行了 又拉了



没有进行同步操作



![](/1.png)



# 并发编程的挑战之资源限制

https://www.cnblogs.com/sun-rain/p/5735226.html



​        硬件资源

​            服务器： 1m

​            本机：2m 带宽20m 下载速度2m/s



​            带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。



​        软件资源

​            数据库连接 500个连接  1000个线程查询  并不会因此而加快

​            socket





# 进程与线程的区别

​        

​        **进程：是系统进行分配和管理资源的基本单位**



​        **线程：进程的一个执行单元，是进程内调度的实体、是CPU调度和分派的基本单位，是比进程更小的独立运行的基本单位。线程也被称为轻量级进程,线程是程序执行的最小单位。**    



​        一个程序至少一个进程，一个进程至少一个线程。



​        进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。

​        而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。

​        **线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式进行。**

​        如何处理好同步与互斥是编写多线程程序的难点。

​        多进程程序更健壮，进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，

​        而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，所以可能一个线程 出现问题，进而导致整个程序出现问题



# 线程的状态及其相互转换

1. ​        初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。
2. ​        运行(RUNNABLE):处于可运行状态的线程正在JVM中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。
3. ​        阻塞(BLOCKED)：线程阻塞于synchronized锁，等待获取synchronized锁的状态。
4. ​        等待(WAITING)：Object.wait()、join()、 LockSupport.park(),进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。
5. ​        超时等待(TIME_WAITING)：Object.wait(long)、Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil，该状态不同于WAITING，
6. ​        它可以在指定的时间内自行返回。
7. ​        终止(TERMINATED)：表示该线程已经执行完毕。



Runnable

```java
        // Runnable
//        Thread thread = new Thread(
//                ()->{
//                    try {
//                        System.in.read();
//                    } catch (IOException e) {
//                        e.printStackTrace();
//                    }
//                }
//        );
//        thread.start();
```



block

```java
// Blocked
        Object obj = new Object();
        Thread thread0 = new Thread(
                ()->{
                    synchronized (obj) {
                        try {
                            Thread.sleep(1000_000_000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }

                    }
                }
        );
        thread0.start();

        // 主线程延时
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        Thread thread2 = new Thread(
                () -> {
                    synchronized (obj){

                    }
                }
        );
        thread2.start();
```



waiting

```java
        // wait
        Object obj = new Object();

        Thread thread3 = new Thread(
                ()->{
                    synchronized (obj){
                        try {
                            obj.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                }
        );
        thread3.start();
```





![](/2.png)



#    创建线程的方式

​        1.继承Thread，并重写父类的run方法

```java

package com.dutlzn.juc.Thread;

public class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.setName("线程0");
        myThread.start();
    }
}

```



​        2.实现Runable接口，并实现run方法

```java
package com.dutlzn.juc.Thread;

public class MyRunnable implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.setName("线程1");
        thread.start();
    }
}

```



​        实际开发中，选第2种：java只允许单继承

​        增加程序的健壮性，代码可以共享，代码跟数据独立



​        1.使用匿名内部类

```java
package com.dutlzn.juc.Thread;

// 匿名内部类
public class MyThread2 {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        });

        thread.setName("线程3");

        thread.start();
    }
}

```



​        2.Lambda表达式

```java
package com.dutlzn.juc.Thread;

public class Lambda {
    public static void main(String[] args) {
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName());
        }).start();
    }
}

```



​        3.线程池

```java
package com.dutlzn.juc.Thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPool {
    public static void main(String[] args) {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        executorService.execute( ()-> {
            System.out.println(Thread.currentThread().getName());
        });

    }
}

```





# 线程的挂起跟恢复

## Thread.sleep 和 Object.wait的区别

https://www.cnblogs.com/ylxn/p/10395315.html

##    什么是挂起线程？

​            线程的挂起操作实质上就是使线程进入“非可执行”状态下，**在这个状态下CPU不会分给线程时间片**，进入这个状态可以用来暂停一个线程的运行。

​            在线程挂起后，可以通过重新唤醒线程来使之恢复运行



##       为什么要挂起线程？

​            cpu分配的时间片非常短、同时也非常珍贵。避免资源的浪费。



##         如何挂起线程？

​            被废弃的方法

​                thread.suspend() 该方法不会释放线程所占用的资源。如果使用该方法将某个线程挂起，则可能会使其他等待资源的线程死锁

​                thread.resume() 方法本身并无问题，但是不能独立于suspend()方法存在

```java
package com.dutlzn.juc.Hang;

// 线程挂起操作测试
public class SuspendDemo implements Runnable{
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() +
                "\t执行run方法准备调用Suspend方法");

        // 线程挂起
        Thread.currentThread().suspend();

        System.out.println(Thread.currentThread().getName() +
                "\t执行run方法，调用Suspend方法结束");
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new SuspendDemo());

        thread.start();

        // 休眠一下主线程，让效果更加明显
        try {
            Thread.sleep(3000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 线程唤醒
        thread.resume();



    }
}

```



日常使用还是不要用了，不会释放锁，有可能引发死锁问题

以下代码效果正常

```java
package com.dutlzn.juc.Hang;

/**
 * suspend 死锁问题
 */
public class DeadDemo implements Runnable{

    private static Object object = new Object();

    @Override
    public void run() {
        // 持有资源
        synchronized (object){
            System.out.println(Thread.currentThread().getName() + "占用资源");
            Thread.currentThread().suspend();
        }

        System.out.println(Thread.currentThread().getName() + "释放资源");
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(new DeadDemo(), " 对比线程");
        thread1.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread1.resume();


        Thread thread2 = new Thread(new DeadDemo(), "死锁线程");

        thread2.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        thread2.resume();
    }
}

```

改一下效果不正常

```java
package com.dutlzn.juc.Hang;

/**
 * suspend 死锁问题
 */
public class DeadDemo implements Runnable{

    private static Object object = new Object();

    @Override
    public void run() {
        // 持有资源
        synchronized (object){
            System.out.println(Thread.currentThread().getName() + "占用资源");
            Thread.currentThread().suspend();
        }

        System.out.println(Thread.currentThread().getName() + "释放资源");
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(new DeadDemo(), " 对比线程");
        thread1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread1.resume();


        Thread thread2 = new Thread(new DeadDemo(), "死锁线程");

        thread2.start();
//        try {
//            Thread.sleep(3000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

        thread2.resume();
    }
}

```



​            可以使用的方法

​                wait() 暂停执行、放弃已经获得的锁、进入等待状态

​                notify() 随机唤醒一个在等待锁的线程

​                notifyAll() 唤醒所有在等待锁的线程，自行抢占cpu资源

```java
package com.dutlzn.juc.Hang;

public class WaitDemo implements Runnable{

    private static Object object = new Object();
    private static Object waitObj = new Object();

    @Override
    public void run() {
        // 持有资源
        synchronized (waitObj){
            System.out.println(Thread.currentThread().getName() + "占用资源");
            try {
                waitObj.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }


        System.out.println(Thread.currentThread().getName() + "释放资源");
    }

    public static void main(String[] args) {
        Thread thread1 = new Thread(new WaitDemo(), " 对比线程");
        thread1.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (waitObj) {
            waitObj.notify();
        }

        
    }
}

```





##         什么时候适合使用挂起线程？

​            我等的船还不来(等待某些未就绪的资源)，我等的人还不明白。直到notify方法被调用

# 线程的中断操作

   stop() 废弃方法，开发中不要使用。因为一调用，线程就立刻停止，此时有可能引发相应的线程安全性问题

​        Thread.interrupt方法

​        自行定义一个标志，用来判断是否继续执行

stop示例代码

```java
package com.dutlzn.juc.Interrupt;

public class Demo implements Runnable{
    private static int index = 0;

    @Override
    public void run() {
        while(true){
            index++;
            System.out.println(index + "\t" +Thread.currentThread().getName());

            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


    public static void main(String[] args) {
        Thread thread = new Thread(new Demo());
        thread.start();

        // 主线程睡眠
        try {
            Thread.sleep(4*1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 废弃方法,不推荐使用
        thread.stop();

    }
}

```

线程不安全，示例

```java
package com.dutlzn.juc.Interrupt;

public class UnsafeWithStop implements Runnable{
    private int i = 0;
    private int j = 0;

    @Override
    public void run() {
        i++;

        // 该线程还在休眠，主线程已经结束了
        try {
            Thread.sleep(2000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        j++;
    }

    public void printf(){
        System.out.println("val of i: "+i +"\t val of j: "+j);
    }

    public static void main(String[] args) {
        UnsafeWithStop unsafeWithStop = new UnsafeWithStop();
        Thread thread = new Thread(unsafeWithStop);
        thread.start();

        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        thread.stop();
        unsafeWithStop.printf();
    }
}

```

利用Interrupt

```java
package com.dutlzn.juc.Interrupt;

public class InterruptDemo implements Runnable {
    @Override
    public void run() {
        while(!Thread.currentThread().isInterrupted()){
            System.out.println(Thread.currentThread().getName());

        }

    }

    public static void main(String[] args) {
        Thread thread = new Thread(new InterruptDemo());
        thread.start();

        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        thread.interrupt();


    }
}

```

定义标志位

```java
package com.dutlzn.juc.Interrupt;


public class MyInterruptDemo implements Runnable{

    public static volatile boolean FLAG = true;

    @Override
    public void run() {
        while(FLAG){
            System.out.println(Thread.currentThread().getName());
        }
    }

    public static void main(String[] args) {
        Thread thread = new Thread(new MyInterruptDemo());
        thread.start();


        try {
            Thread.sleep(1000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        FLAG = false;


    }
}

```

# 线程的优先级

**线程的优先级告诉程序该线程的重要程度有多大**。如果有大量线程都被堵塞，都在等候运行，程序会尽可能地先运行优先级的那个线程。  但是，这并不表示优先级较低的线程不会运行。若线程的优先级较低，只不过表示它被准许运行的**机会小**一些而已。



​        线程的优先级设置可以为1-10的任一数值，Thread类中定义了三个线程优先级，分别是：

​        MIN_PRIORITY（1）、NORM_PRIORITY（5）、MAX_PRIORITY（10），一般情况下推荐使用这几个常量，不要自行设置数值。



​        不同平台，对线程的优先级的支持不同。  编程的时候，不要过度依赖线程优先级，如果你的程序运行是否正确取决于你设置的优先级是否按所设置的优先级运行，那这样的程序不正确



​        任务：

​            快速处理：设置高的优先级

​            慢慢处理：设置低的优先级

示例代码:

```java
package com.dutlzn.juc.priority;

/**
 * 线程优先级 测试
 */
public class PriorityDemo {
    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> {
            while (true){
                System.out.println(Thread.currentThread().getName());
//                try {
//                    Thread.sleep(1000L);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
            }
        }, "线程1");

        Thread thread2 = new Thread(() -> {
            while(true){
                System.out.println(Thread.currentThread().getName());
//                try {
//                    Thread.sleep(1000L);
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
            }
        }, "线程2");


        thread1.setPriority(Thread.MIN_PRIORITY);
        thread2.setPriority(Thread.MAX_PRIORITY);

        thread1.start();
        thread2.start();
    }
}

```



# 守护线程

​        线程分类

​            用户线程、守护线程

用户线程，执行完了，才停止，main停止了，但是自定义的线程没有停止，就会继续跑下去



​            **守护线程：任何一个守护线程都是整个程序中所有用户线程的守护者，只要有活着的用户线程，守护线程就活着。当JVM实例中最后一个非守护线程结束时，也随JVM一起退出**



​            守护线程的用处：**jvm垃圾清理线程**



​        建议： 尽量少使用守护线程，因其不可控

​              不要在守护线程里去进行读写操作、执行计算逻辑

```java
package com.dutlzn.juc.guard;

/**
 * 守护线程 测试
 */
public class DemonThreadDemo implements Runnable{
    @Override
    public void run() {
        while(true){
            System.out.println(Thread.currentThread().getName());
        }
    }

    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new DemonThreadDemo());
        thread.setDaemon(true);
        thread.start();
        // 主线程休眠两秒
        Thread.sleep(2000L);

    }
}

```

主线程结束了，守护线程也退出了

----



#  什么是线程安全性？

​        当多个线程访问某个类,不管运行时环境采用何种调度方式或者这些线程如何交替执行,并且在主调代码中不需要任何额外的同步或协同,这个类都能表现出正确的行为,那么就称这个类为线程安全的。----《并发编程实战》



​        什么是线程不安全？

​            **多线程并发访问时，得不到正确的结果。** 

# 从字节码角度剖析线程不安全操作

新建文件夹unsafe

从字节码角度剖析线程不安全操作

​       javac -encoding UTF-8 UnsafeThread.java 编译成.class

​       javap -c UnsafeThread.class 进行反编译，得到相应的字节码指令



​       0: getstatic     #2               获取指定类的静态域，并将其押入栈顶

​       3: iconst_1                       将int型1押入栈顶

​       4: iadd                           将栈顶两个int型相加，将结果押入栈顶

​       5: putstatic     #2               为指定类静态域赋值

​       8: return



​       例子中，产生线程不安全问题的原因：

​            **num++ 不是原子性操作**，被拆分成好几个步骤，在多线程并发执行的情况下，因为cpu调度，多线程快递切换，有可能两个同一时刻都读取了同一个num值，之后对它进行+1操作，导致线程安全性。

# 原子性操作

##         什么是原子性操作

​            一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

​            A想要从自己的帐户中转1000块钱到B的帐户里。那个从A开始转帐，到转帐结束的这一个过程，称之为一个事务。在这个事务里，要做如下操作：

​            \1. 从A的帐户中减去1000块钱。如果A的帐户原来有3000块钱，现在就变成2000块钱了。

​            \2. 在B的帐户里加1000块钱。如果B的帐户如果原来有2000块钱，现在则变成3000块钱了。

​            如果在A的帐户已经减去了1000块钱的时候，忽然发生了意外，比如停电什么的，导致转帐事务意外终止了，而此时B的帐户里还没有增加1000块钱。

​            那么，我们称这个操作失败了，要进行回滚。回滚就是回到事务开始之前的状态，也就是回到A的帐户还没减1000块的状态，B的帐户的原来的状态。

​            此时A的帐户仍然有3000块，B的帐户仍然有2000块。

​            **通俗点讲：操作要成功一起成功、要失败大家一起失败**



##         如何把非原子性操作变成原子性

​            **volatile关键字仅仅保证可见性，并不保证原子性**

​            **synchronize关键字，使得操作具有原子性**



## 深入理解Volatile

参考

https://www.cnblogs.com/zhengbin/p/5654805.html

重排序





这样写就可以让操作具有原子性

```java
package com.dutlzn.juc.Unsafe;

import java.util.concurrent.CountDownLatch;

// 线程不安全例子
public class UnsafeDemo {
    private static  int num = 0;
    private static CountDownLatch countDownLatch = new CountDownLatch(10);

    static synchronized void inCreate() {
        num++;
    }



    public static void main(String[] args) {
        System.out.println("unsafe test");
//        inCreate();
//        System.out.println(num);

        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                for (int i1 = 0; i1 < 100; i1++) {
                    inCreate();

                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                //每个线程执行完成之后，调用countdownLatch
                countDownLatch.countDown();
            }).start();

        }

//        try {
//            Thread.sleep(1000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

//        System.out.println(num);

        while(true){
            if(countDownLatch.getCount() == 0){
                System.out.println(num);
                break;
            }
        }
    }

}

```



# 深入理解synchronized

## 内置锁 

​            每个java对象都可以用做一个实现同步的锁，这些锁称为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。



## 互斥锁

​            内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。

## 如何用

​        修饰普通方法：锁住对象的实例 ， 是分开的

```java
package com.dutlzn.juc.safe;

public class SynDemo {
    public synchronized void out() {
        System.out.println(Thread.currentThread().getName());
        try {
            Thread.sleep(5000l);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }

//    public synchronized static void staticOut() {
//
//    }
//
//
//    public void myOut() {
//        synchronized (){
//
//        }
//    }

    public static void main(String[] args) {
        SynDemo synDemo1 = new SynDemo();
        SynDemo synDemo2 = new SynDemo();
        new Thread(()->{
            synDemo1.out();
        }).start();
        new Thread(()->{
            synDemo2.out();
        }).start();
    }
}

```

同时输出

​        修饰静态方法：锁住整个类

```java
package com.dutlzn.juc.safe;

public class SynDemo {
//    public synchronized void out() {
//        System.out.println(Thread.currentThread().getName());
//        try {
//            Thread.sleep(5000l);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//
//    }

    public synchronized static void staticOut() {
        System.out.println(Thread.currentThread().getName());

        try {
            Thread.sleep(5000L);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
//
//
//    public void myOut() {
//        synchronized (){
//
//        }
//    }

    public static void main(String[] args) {
        SynDemo synDemo1 = new SynDemo();
        SynDemo synDemo2 = new SynDemo();
        new Thread(()->{
            staticOut();
        }).start();
        new Thread(()->{
            staticOut();
        }).start();
    }
}

```

先后顺序 其他方面一直在等待当前线程的锁





​        修饰代码块： 锁住一个对象 synchronized (lock) 即synchronized后面括号里的内容

```java
package com.dutlzn.juc.safe;

public class SynDemo {
//    public synchronized void out() {
//        System.out.println(Thread.currentThread().getName());
//        try {
//            Thread.sleep(5000l);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//
//    }


//
//    public synchronized static void staticOut() {
//        System.out.println(Thread.currentThread().getName());
//
//        try {
//            Thread.sleep(5000L);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//
//    }
//


    private static Object lock = new Object();
    public void myOut() {
        synchronized (lock){
            System.out.println(Thread.currentThread().getName());
            try {
                Thread.sleep(5000l);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    }

    public static void main(String[] args) {
        SynDemo synDemo1 = new SynDemo();
        SynDemo synDemo2 = new SynDemo();
        new Thread(()->{
            synDemo1.myOut();
        }).start();
        new Thread(()->{
            synDemo2.myOut();
        }).start();
    }
}

```

先后顺序

# volatile关键字及其使用场景

## volatile关键字

​        **能且仅能修饰变量**

​        保证该变量的可见性，volatile关键字**仅仅保证可见性，并不保证原子性**

​        **禁止指令重排序**



​        A、B两个线程同时读取volatile关键字修饰的对象

​        A读取之后，修改了变量的值

​        修改后的值，对B线程来说，是可见



volatile不使用锁



##  使用场景

​            1：作为线程开关

```java
package com.dutlzn.juc.safe;

public class VolatileDemo implements Runnable{
    private static volatile boolean flag = true;

    @Override
    public void run() {
        while(flag){
            System.out.println(Thread.currentThread().getName());
        }
    }
}

```



​            2：单例，修饰对象实例，禁止指令重排序



# 单例和线程安全

##         饿汉式--本身线程安全

​            在类加载的时候，就已经进行实例化，无论之后用不用到。如果该类比较占内存，之后又没用到，就白白浪费了资源。

```java
package com.dutlzn.juc.safe;


/**
 * 饿汉式单例模式
 * 在类加载的时候，就已经有实例化了
 *
 */
public class HungerSingleton {
    private static HungerSingleton ourInstance = new HungerSingleton();

    public static HungerSingleton getInstance() {
        return ourInstance;
    }

    private HungerSingleton() {

    }

    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {
            new Thread(
                    () -> {
                        System.out.println(HungerSingleton.getInstance());
                    }
            ).start();
        }
    }
}

```



##         懒汉式 -- 最简单的写法是非线程安全的

​            在需要的时候再实例化



