---
typora-root-url: /images

---

# Java核心技术

# final、finally、 finalize

fnal可以用来修饰类、方法、变量，分别有不同的意义，fnal修饰的class代表不可以继承扩展，fnal的变量是不可以修改的，而fnal的方法也是不可以重写的（override）。

fnally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-fnally或者try-catch-fnally来进行类似关闭JDBC连接、保证unlock锁等动作。

fnalize是基础类java.lang.Object的一个方法，**它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。**fnalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated。







# 强引用、软引用、弱引用、幻象引用

除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象

不同的引用类型，主要体现的是对象不同的**可达性（reachable）状态和对垃圾收集**的影响。

谓**强引用**（"Strong" Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。



**软引用（**SoftReference），是一种相对强引用弱化一些的引用，可以让**对象豁免一些垃圾收集**，只有当JVM认为内存不足时，才会去试图回收软引用指向的对象。JVM会确保在抛出OutOfMemoryError之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。



**弱引用（WeakReference）并不能使对象豁免垃圾收集**，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。



对于**幻象引用，有时候也翻译成虚引用**，你不能通过它访问对象。幻象引用仅仅是提供了一种**确保对象被finalize以后**，做某些事情的机制，比如，通常用来做所谓的Post-Mortem清理机制，java平台自身Cleaner机制等，也有人利用幻象引用监控对象的创建和销毁。



充分理解这些引用，对于我们设计可靠的缓存等框架，或者诊断应用OOM等问题，会很有帮助。比如，诊断MySQL connector-j驱动在特定模式下（useCompression=true）的
内存泄漏问题，就需要我们理解怎么排查幻象引用的堆积问题。



## 对象可达性状态流转分析





简单总结了对象生命周期和不同可达性状态，以及不同状态可能的改变关系



![](/1.png)



我来解释一下上图的具体状态，这是Java定义的不同**可达性级别（reachability level）**，具体如下：

强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。

软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。

弱可达（Weakly Reachable），类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。这是十分临近finalize状态的时机，当弱引用被清除的时候，就符合fnalize的条件了。

幻象可达（Phantom Reachable），上面流程图已经很直观了，就是没有强、软、弱引用关联，并且fnalize过了，只有幻象引用指向这个对象的时候。

当然，还有一个最后的状态，就是不可达（unreachable），意味着对象可以被清除了。
判断对象可达性，是JVM垃圾收集器决定如何处理对象的一部分考虑。







