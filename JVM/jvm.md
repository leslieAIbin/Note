---

typora-root-url: /images
---



# Java虚拟机(JVM)笔记

参考

https://www.jianshu.com/p/9e6841a895b4

https://blog.csdn.net/q961250375/article/details/107499173  这个相对来说比较好



思维导图总结

https://www.edrawsoft.cn/viewer/public/s/dbf59469789103





# JVM架构图

淘宝大神的那本书  深入理解jvm

大数据 还是 java都要

* 请你谈谈堆jvm的理解？java8的虚拟机有什么更新？（java8之前和java8之后虚拟机的区别）
* 什么是OOM？什么是StackOverflowError?有哪些方法分析？ 是错误还是异常
* jvm的常用参数调优你知道是哪些吗？
* 谈谈jvm中，对类加载器的理解

## jvm体系结构概述

jvm位置

![](/1.png)

**jvm是运行在操作系统之上的，与硬件没有直接的交互**

可不可以直接调用底层的硬件？native jai java本地接口 去调用底层的硬件接口

jvm体系结构概览

![](/2.png)



亮点的地方有两个特点：

* 所有线程共享（灰色是线程私有）
* 亮色地方存在垃圾回收

# 类加载器

方法区不是放方法的地方，放类的描述信息，放模板的地方。

![](/3.png)

类装载器，类似快递员，不是只有一种，

class.forName("") 根据这个类的模板生成一个实例

Car Class被装载进了方法区

car1 car2 car3一样是因为来自于同一个模板

模板是一个，实例有n个

java图标是一杯咖啡，cafe babe 就是文件开头特定标识

装载器三个，四个



![](/4.png)



jre ( java run environment ) rt.jar 里面有lang object.class  被启动类加载器 加载了

随着java世界的变化，后面添加的扩展包，用扩展类加载器， javax..

1. 启动类加载器;
2. 扩展类加载器:
3. 用户自定义加载器:
4. 系统加载器:





sun.misc.Launcher$  就是rt.jar/sum/misc 路径下的 Launcher.class

JVM相关调用的入口程序

classLoader 

双亲委派 机制 

我爸是李刚，有事找我爹

先去最上面的找，找不到，就去下一层

沙箱安全机制 不加载源代码，防止污染代码

https://blog.csdn.net/qq_30336433/article/details/83268945



![](/5.png)



**executing engine** 执行引擎负责解释命令，提交操作系统执行



首先加载的是Bootstrap加载器，由于JVM中有java.lang.String这个类，所以会首先加载这个类，而不是自己写的类，而这个类中并无main方法，所以会报“在类 java.lang.String 中找不到 main 方法”。

这个问题就涉及到，如果有两个相同的类，那么java到底会用哪一个？如果使用用户自己定义的java.lang.String，那么别使用这个类的程序会去全部出错，所以，为了保证用户写的源代码不污染java出厂自带的源代码，而提供了一种“双亲委派”机制，保证“沙箱安全”。即先找到先使用。



# 本地接口

![](/6.png)

多线程的6个状态

两个thread.start() 为什么会报错？

```
if (threadStatus != 0)    throw new IllegalThreadStateException();
```

Thread类中竟然有一个只有声明没有实现的方法，并使用`native`关键字。用native表示，也此方法是系统级（底层操作系统或第三方C语言）的，而不是语言级的，java并不能对其进行操作。native方法装载在native method stack中。 特殊的栈

（微服务）不关心内部的东西，只关心他的接口 SpringClound



为什么是native



# PC寄存器

pc寄存器记录了方法之间的调用和执行情况，类似排版值日表、

from 地址1 to 地址2

他是当前线程所执行的字节码的行号指示器

![](/7.png)

**native方法不归java管，所以计数器是空的**

pc寄存器在cpu内，就相当于排版值日表，火车的连接器

几乎不存在gc垃圾回收 几十kb  

多线程.start()不一定马上启动，在CPU和操作系统调度下执行 真正启动的是start0()

native是一个关键字，声明有，无实现。



# 方法区

![](/8.png)

- 所有线程共享（灰色是线程私有）

- 亮色地方存在垃圾回收 

  方法区 绝对不是放方法的地方，他是存储的每一个类的结构信息(比如static) 模板信息

  永久代和元空间的解释：
  方法区是一种规范，类似于接口定义的规范：`List list = new ArrayList();`
  把这种比喻用到方法区则有：

  接口  f = new 实现类()

  1. java 7中：`方法区 f = new 永久代();`
  2. java 8中：`方法去 f = new 元空间();`

  Car Class 就是模板信息 就在方法区里

# 栈

最重要的是堆 和 java栈

**栈管运行，堆管存储**

e.printStackTrace()

new 出来的放在堆里面

controller->service->dao 栈

程序 = 算法 + 数据结构

程序 = 框架 + 业务逻辑



队列FIFO

栈 FILO

![](/9.png)



栈操作：pc寄存器





```java
// 输入参数 方法就是一颗子弹，输入参数输出参数就是子弹壳
public int add(int x, int y){
    // 方法内的参数
    int result = -1;
    result  = x+y;
    // 输出参数
    return result;
}

public static void main(String[] args){
    // 
    Person p1 = new Person();
}
```



java方法 进入了虚拟机中，就成了栈帧

![](/10.png)

[Java基础-方法区以及static的内存分配图](https://www.cnblogs.com/lwthad/p/10258278.html)

https://www.cnblogs.com/lwthad/p/10258278.html



**注意：**

- 栈管运行，堆管存储

- 栈是线程私有，不存在垃圾回收

- 栈帧的概念：java中的方法被扔进虚拟机的栈空间之后就成为“栈帧”，比如main方法，是程序的入口，被压栈之后就成为栈帧。

  

![](/11.PNG)





![](/12.png)



m1 {

m1()

}

m1就是子弹，压多了，就会stackOverflowError  SOF

方法深度调用，把栈给撑爆了

这个是错误还是异常？错误，如果是异常，可以throw 

serializable <----Throwable < ---- Exception 

serializable <----Throwable <---Error

![](/13.png)





# 栈 堆 方法区的交互关系



![](/14.png)

HotSpot：如果没有明确指明，JDK的名字就叫HotSpot

元数据：描述数据的数据（即模板，也就是“大Class”）
上面的关系图的一个实例为下图：

![](/15.png)





高斯林提出了一套jdk接口规范，sun实现了这些接口规范就是HotSpot

java 最好的两家公司 阿里巴巴 + 美团 大数据 



# Heap堆结构简介

堆不是线程私有的，有垃圾回收机制

放的类元数据



新生区， 养老区，永久区

![](/16.png)



养老区，老年区

![](/17.png)

**注意：**

-  **Java 7**之前和图上一模一样，**Java 8**把**永久区**换成了**元空间** 
- **堆逻辑上由”新生+养老+元空间“三个部分组成，物理上由”新生+养老“两个部分组成**
- 当执行`new Person()；`时，其实是new在新生区的伊甸园区，然后往下走，走到养老区，但是并未到元空间。



# Heap堆new对象

![](/18.png)



注意：

- GC发生在伊甸园区，当对象快占满新生代时，就会发生YGC（Young GC，轻量级GC）操作，伊甸园区基本全部清空
- 幸存者0区(S0)，别名“from区”。伊甸园区没有被YGC清空的对象将移至幸存者0区，幸存者1区别名“to 区”
- 每次进行YGC操作，幸存的对象就会从伊甸园区移到幸存者0区，如果幸存者0区满了，就会继续往下移，如果经历数次YGC操作对象还没有消亡，最终会来到养老区
- 如果到最后，养老区也满了，那么就对养老区进行FGC(Full GC，重GC)，对养老区进行清洗
- 如果进行了多次FGC之后，还是无法腾出养老区的空间，就会报**OOM（out of Memory）**异常
- **from区和to区位置和名分不是固定的，每次GC过后都会交换，GC交换后，谁空谁是to区**
- https://blog.csdn.net/z453588/article/details/83743837

S0 = from



# TransferValue

-----



基本类型传递复印件

只是对我手上的复印件进行操作

班长手上的原册没有改变

---



引用类型传的是同样的引用地址



String 和 其他类引用变量有不一样

String 也是引用类型，照理来说，如果进入一个函数更改，最后他的值也会更改

但实际上String类型变量没有改变，这是因为**字符串常量池**的缘故



此时内存中没有abc，在常量池中新建了abc,main方法中的引用变量指向abc

然后当str被传入方法中，方法汇总的引用也指向abc

但是当方法执行str="xxx"这行代码时，由于常量池中并没有“xxx”，所以将会在常量池中新建一个xxx

由方法中的引用变量指向它

Java的TransferValue中，传基本类型的值原值不变，传引用类型的参数，参数变化，原引用的值也会发生改变。但是在常量池中的引用类型变量除外



# 对象的生命周期和GC

From和to位置和名次不是固定不变的，每次gc之后会有交换

![](/19.png)





**注意：**

- 整个堆分为新生区和养老区，新生区占整个堆的1/3，养老区占2/3。新生区又分为3份：伊甸园区：幸存者0区(from区):幸存者1区(to区) = 8:1:1
- **每次从伊甸园区经过GC幸存的对象，年龄(代数)会+1**



GC之后有交换，谁空谁是to





# 永久带

![](/20.png)

临时对象，在伊甸园生，在伊甸园死

java8优化之后，很少有对象去养老区

![](/21.png)

临时对象就是说明，其在伊甸园区生，也在伊甸园区死。

**堆逻辑上由”新生+养老+元空间“三个部分组成，物理上由”新生+养老“两个部分组成，元空间也叫方法区**

**永久代(方法区)几乎没有垃圾回收，里面存放的都是加载的rt.jar等，让你随时可用**



java7 永久代， java8 元空间

逻辑上永久代加碓空间

![](/22.png)

元数据，就相当于springboot 添加的jar包



**方法区和永久代**之间的关系就像是java 接口和类的关系

https://blog.csdn.net/u010325193/article/details/86746447

这就是java7和java8的区别

##### 



# 堆参数调整

jvm 垃圾收集（java garbage collection）

![](/23.png)



面试的时候要问清楚 minor GC major GC  full GC 他问的major GC到底是哪一个？

上面的图展示的是物理上的堆，分为两块，新生区和养老区。

堆的参数主要有两个：`-Xms``Xmx`

1.  `-Xms`堆的初始化的大小
2.  `Xmx`堆的最大化

Young Gen(新生代)有一个参数`-Xmn`，这个参数可以调新生区和养老区的比例。但是，这个参数一般不调。

永久代也有两个参数：`-XX:PermSize`，`-XX:MaxPermSize`，可以分别调永久带的初始值和最大值。**Java 8 后没有这两个参数啦**，因为Java 8后元空间不在虚拟机内啦，而是在本机物理内存中

![](/24.png)





![](/25.png)





OOM有8种

![](/26.png)



Java一切皆对象， 把绿色区域的runtime area 抽象成了Runtime对象

- **注意：**JVM参数调优，平时可以随便挑初始大小和最大大小，但是**实际工作中，初始大小和最大大小应该是一致的，原因是避免内存忽高忽低产生停顿**
- IDEA 的JVM内存配置



如何在idea种进行内存配置

run -> edit configurations

在VM Options中输入以下参数:-Xms1024m -Xmx1024m -XX:+PrintGCDetails

![](/27.png)

## 如何模拟OOM

把堆内存调成10M后，再一直new对象，导致Full GC也无法处理，直至撑爆堆内存，查看堆溢出错误(OOM)，程序及结果如下：

```
    String str = "luzhenning";
        while(true){
            str += str + new Random().nextInt(88888888) + new Random().nextInt(999999999);
        }
```



40MB

```
byte[] bytes = new byte[40*1024*1024];
```

Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
	at JVMCode.main(JVMCode.java:21)



OOM的错误就说明Full GC都撑不住了



# GC收集日志信息



**GC收集日志信息详解**

- 第一次进行YGC相关参数：
   [PSYoungGen: 2008K->482K(2560K)] 2008K->782K(9728K), 0.0011440 secs]  [Times: user=0.00 sys=0.00, real=0.00 secs]

![](/28.png)

最后一次进行FGC相关参数：
[Full GC (Allocation Failure) [PSYoungGen: 0K->0K(2048K)] [ParOldGen: 4025K->4005K(7168K)] 4025K->4005K(9216K), [Metaspace: 3289K->3289K(1056768K)], 0.0082055 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]



![](/29.png)





![](/30.png)



# 引用计数法

垃圾收集方法（分代收集算法）

- **面试题：GC是什么（分代收集算法）**
  - 次数上频繁收集Young区
  - 次数上较少收集Old区
  - 基本不动元空间



![](/31.png)



![](/32.png)

JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。因此GC按照回收的区域又分了两种类型，一种是普通GC（minor GC or Young GC），一种是全局GC（major GC or Full GC）

Minor GC和Full GC的区别
 　　普通GC（minor GC）：只针对新生代区域的GC,指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所以Minor GC非常频繁，一般回收速度也比较快。
 　　全局GC（major GC or Full GC）：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上 (因为养老区比较大，占堆的2/3)



**面试题：GC的四大算法（后有详解）**

- 引用计数法

- 复制算法（Copying）

- 标记清除（Mark-Sweep)

- 标记压缩（Mark-Compact)

  

主程序 两个线程， gc 线程，主线程

## 引用计数法：

![](/33.png)



每引用一个我，就加一个1，当没有了一个引用之后，就减去一个1，最后减到了0就说明是垃圾了

System.gc();只是建议Java虚拟机对此部分内存进行回收，但是不一定会发生G

禁止使用System.gc()

# 复制算法

最常用算法

年轻代种使用的是Minor GC，这种GC算法采用的是复制算法

年轻代中使用的是Minor GC（YGC），这种GC算法采用的是复制算法(Copying)。

Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old  generation中，也即一旦收集后，Eden是就变成空的了。

当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。

-XX:MaxTenuringThreshold — 设置对象在新生代中存活的次数





年轻代中的GC,主要是复制算法（Copying）。 HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8:1:1,一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(90%以上)，**所以在年轻代的垃圾回收算法使用的是复制算法**，复制算法的基本思想就是将内存分为两块，每次只用其中一块(from)，当这一块内存用完，就将还活着的对象复制到另外一块上面。**复制算法的优点是不会产生内存碎片，缺点是耗费空间**。



![](/34.png)



在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。**经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”**。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

![](/35.png)

GC之后有交换，谁空谁是to

因为Eden区对象一般存活率较低，一般的，使用两块10%的内存作为空闲和活动区间，而另外80%的内存，则是用来给新建对象分配内存的。一旦发生GC，将10%的from活动区间与另外80%中存活的eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，以此类推。



复制算法它的缺点也是相当明显的:

- 1. 它浪费了一半的内存，这太要命了。 空间
- 1. 如果对象的存活率很高，我们可以极端一点，假设是100%存活，那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。 所以从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行，而且最重要的是，我们必须要克服50%内存的浪费。



# 标记清除

**复制算法的缺点就是费空间，其是用在年轻代的，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。**



![](/36.png)



不需要额外的空间

但是 两次扫描，耗时严重，会产生内存碎片

用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将程序暂停，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。

主要进行两项工作，第一项则是标记，第二项则是清除。

- 标记：从引用根节点开始标记遍历所有的GC Roots， 先标记出要回收的对象。
- 清除：遍历整个堆，把标记的对象清除。



**缺点：此算法需要暂停整个应用，会产生内存碎片**

**标记清除算法小结：**

- 1、首先，它的缺点就是效率比较低（递归与全堆对象遍历），而且在进行GC的时候，需要停止应用程序，这会导致用户体验非常差劲
- 2、其次，主要的缺点则是这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。



# 标记压缩



标记压缩(Mark-Compact)又叫标记清除压缩(Mark-Sweep-Compact)，或者标记清除整理算法。老年代一般是由**标记清除**或者是**标记清除与标记整理的混合**实现



![](/37.png)





![](/38.png)



**面试题：四种算法那个好**
Answer：没有那个算法是能一次性解决所有问题的，因为JVM垃圾回收使用的是**分代收集算法**，没有最好的算法，只有根据每一代他的垃圾回收的特性用对应的算法。**新生代使用复制算法，老年代使用标记清除和标记整理算法。**没有最好的垃圾回收机制，只有最合适的。



**面试题：请说出各个垃圾回收算法的优缺点**

-  **内存效率：**复制算法>标记清除算法>标记整理算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。
-  **内存整齐度：**复制算法=标记整理算法>标记清除算法。
-  **内存利用率：**标记整理算法=标记清除算法>复制算法。

可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而**为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些**，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程

难道就没有一种最优算法吗？Java 9 之后出现了**G1垃圾回收器（使用分代收集）**，能够解决以上问题，有兴趣参考[这篇文章](https://www.jianshu.com/p/ba415aa2330b)。



https://www.jianshu.com/p/0f1f5adffdc1



#### 总结：

- ##### 年轻代(Young Gen)

年轻代特点是区域相对老年代较小，对像存活率低。

这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。

- ##### 老年代(Tenure Gen)

老年代的特点是区域较大，对像存活率高。

这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是由标记清除或者是标记清除与标记整理的混合实现。

Mark阶段的开销与存活对像的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。

Sweep阶段的开销与所管理区域的大小形正相关，但Sweep“就地处决”的特点，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。

Compact阶段的开销与存活对像的数据成开比，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。

基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。

## 常见面试题

* JVM内存模型以及分区，需要详细到每个区放什么
* 堆里面的分区：Eden、Survival from to 老年代，各自的特点
* GC的三种收集方法，标记清除 标记整理 标记压缩 引用计数器 （还有一种混用机制）各自的原理与特点，分别用在什么地方
* Minor GC与Full GC分别在什么时候调用

# JMM

数据库的事务，这次会话里面的所有sql 要么一起成功，要么一起失败，这是一个不可分割的操作，就是事务



**java 内存模型**  在高并发里面经常会碰见

volatile是java虚拟机提供的轻量级的同步机制  **volatile是乞丐版的synchronized**

* 保证可见性
* 不保证原子性
* 禁止指令重排



JMM你谈谈 线程安全性获得保证

JMM有三个特点： **可见性 、 原子性、有序性**

可见性 通知机制   多个线程操作同一个变量时，当一个先执行的线程改动了这个变量的值时，应当通知其他线程变量的值已经被改动了，原来的值将不可用。

原子性：不可分割

有序性：我怎么写的我就怎么执行

VolatileDemo 代码演示可见性+原子性



cpu>内存>硬盘 （高io) 

redis 在内存 

cpu是计算单元不是存储单元， cpu三级缓存 这个缓存在cpu和内存中间区域



多线程操作共享变量，每个线程先从主物理内存拷贝一份到自己的工作内存 内存快照

在自己的工作内存里面改变变量，在重写到主物理内存 可见性



**JMM 本身是一种抽象的概念，并不真实存在。**它描述的是一组规范或规则，通过这些规则定义了程序中各个变量（包括实例字段，静态字段，和构成数组对象的元素）的访问方式



![](/39.png)



![](/40.png)



加了volatile 可以添加可见性， 立马通知别的线程，如果不加 有些线程不能立马知道其他线程更改了共享变量





你在哪些地方用到过volatile













# 加载代码验证

所有代码加载的话， 

先有模板，静态先行，静态的东西只被加载一次

静态的东西 方法区

 静态方法 > 构造块 > 构造方法



# 可达性分析



